# Refresh sourcoise cache by executing sources selected

All scripts (passed to `sourcoise_refresh()`) are executed with logging
enabled.

## Usage

``` r
sourcoise_refresh(
  what = NULL,
  force_exec = TRUE,
  unfreeze = TRUE,
  quiet = FALSE,
  init_fn = getOption("sourcoise.init_fn"),
  root = getOption("sourcoise.root"),
  priotirize = TRUE,
  log = "INFO",
  .progress = TRUE
)
```

## Arguments

- what:

  (tibble) a tibble as generated by
  [`sourcoise_status()`](https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.md),
  possibly filtered, (defaut to `source_status()` ). What can also be a
  vector of strings to filter srouces files by name.

- force_exec:

  (boolean) (default `FALSE`) if `TRUE` code is executed, no matter what
  is cached

- unfreeze:

  (boolean) (default `TRUE`) when possible, unfreeze and uncache .qmd
  files in a quarto project when data used by those .qmd has been
  refreshed

- quiet:

  (boolean) (default `FALSE`) no message if TRUE

- init_fn:

  (function) (default `NULL`) execute a function before sourcing to
  allow initialization

- root:

  (default `NULL`) force root to be set, instead of letting the function
  finding the root, for advanced uses

- priotirize:

  (boolean) (defaut `TRUE`) will set priority based on pattern of
  execution

- log:

  (character) (default `"INFO"`) log levels as in
  [`logger::log_threshold()`](https://daroczig.github.io/logger/reference/log_threshold.html)
  (c("OFF", "INFO", ...)), comes with a small performance cost

- .progress:

  (boolean) (default `TRUE`) displays a progression bar based on
  previous execution timings

## Value

a list of r scripts (characters) executed, with timing and success and a
side effect on caches

## Details

The function returns the list of script executed but its main effect is
a side-effect as scripts are executed and caches updates accordingly.
Note also that log files reflect execution and track possible errors.
Because of logging the execution comes with a loss in performance, which
is not an issue if scripts are long to execute.

It is possible to execute `sourcoise_refresh()` without execution
forcing (`force_exec=FALSE`) or with it. Forced execution means that the
script is executed even if the cache is valid. In the case of non forced
execution, execution is triggered by other cache invalidation tests
(change in source file, lapse or tacked files).

When scripts are linked to qmds (i.e. when run in a quarto project), it
is possible to unfreeeze and uncache those qmds with the option
`unfreeze=TRUE`. This allows to refresh the cahe and then render the
qmds using the new data.

It is possible to pass to refresh a function that will be executed
before every script. This allows to load packages and declare global
variables that can be used in each script. If packages are loaded inside
the script, then this is not needed.

Parameters registered ins
[`sourcoise_status()`](https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.md)
such as `wd` or `args` are used to execute the script.

Defining a `priority` in
[`sourcoise()`](https://xtimbeau.github.io/sourcoise/reference/sourcoise.md),
will change the order of execution of refresh. This can be set
automatically using `priotirize` option. After execution of one refresh,
by setting higher priority to more used files.

## See also

Other sourcoise:
[`sourcoise()`](https://xtimbeau.github.io/sourcoise/reference/sourcoise.md),
[`sourcoise_clear()`](https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.md),
[`sourcoise_clear_all()`](https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear_all.md),
[`sourcoise_reset()`](https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.md),
[`sourcoise_status()`](https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.md)

## Examples

``` r
dir <- tempdir()
set_sourcoise_root(dir)
#> /tmp/RtmpOyU1Hu
fs::file_copy(
   fs::path_package("sourcoise", "some_data.R"),
   dir,
   overwrite = TRUE)
# Force execution
data <- sourcoise("some_data.R", force_exec = TRUE)
#> Called from: cache_data(our_data, ctxt)
#> debug: exist <- FALSE
#> debug: if (nrow(all_metas) > 0) {
#>     meta <- slice(dplyr::filter(all_metas, .data$data_hash == 
#>         new_data_hash), 1)
#>     if (nrow(meta) == 1) {
#>         exist <- TRUE
#>         exists_data_file <- fs::path_file(dplyr::pull(meta, .data$data_file))
#>         exists_data_file <- fs::path_join(c(ctxt$full_cache_rep, 
#>             exists_data_file))
#>         exists <- fs::file_exists(exists_data_file)
#>         finfo <- fs::file_info(exists_data_file)
#>         exists_file_size <- finfo$size
#>         exists_data_date <- as.character(dplyr::pull(meta, .data$data_date))
#>     }
#> }
#> debug: if (!fs::dir_exists(ctxt$full_cache_rep)) fs::dir_create(ctxt$full_cache_rep, 
#>     recurse = TRUE)
#> debug: data$data_hash <- new_data_hash
#> debug: if (!ctxt$nocache) {
#>     les_metas <- data
#>     les_metas$data <- NULL
#>     les_metas$file <- NULL
#>     les_metas$ok <- NULL
#>     les_metas$priority <- ctxt$priority
#>     if (!exist) {
#>         fnd <- fs::path_join(c(ctxt$full_cache_rep, stringr::str_c(ctxt$basename, 
#>             "_", stringr::str_c(data$data_hash, ".qs2"))))
#>         qs2::qs_save(data$data, file = fnd, nthreads = getOption("sourcoise.nthreads"))
#>         f_i <- fs::file_info(fnd)
#>         les_metas$file_size <- f_i$size
#>         les_metas$data_date <- as.character(f_i$modification_time)
#>         if (f_i$size > ctxt$limit_mb * 1024 * 1024) {
#>             fs::file_delete(fnd)
#>             logger::log_warn("cached data not saved because ({scales::label_bytes()(file_size)} is over the {ctxt$limit_md} Mb limit.")
#>         }
#>     }
#>     else {
#>         fnd <- exists_data_file
#>         les_metas$file_size <- exists_file_size
#>         les_metas$data_date <- exists_data_date
#>     }
#>     les_metas$data_file <- data$data_file <- fs::path_file(fnd)
#>     if (!is.null(ctxt$log_file)) 
#>         les_metas$log_file <- fs::path_rel(ctxt$log_file, ctxt$root)
#>     data$data_date <- les_metas$data_date
#>     write_meta(les_metas, ctxt)
#>     prune_cache(ctxt)
#> }
#> debug: les_metas <- data
#> debug: les_metas$data <- NULL
#> debug: les_metas$file <- NULL
#> debug: les_metas$ok <- NULL
#> debug: les_metas$priority <- ctxt$priority
#> debug: if (!exist) {
#>     fnd <- fs::path_join(c(ctxt$full_cache_rep, stringr::str_c(ctxt$basename, 
#>         "_", stringr::str_c(data$data_hash, ".qs2"))))
#>     qs2::qs_save(data$data, file = fnd, nthreads = getOption("sourcoise.nthreads"))
#>     f_i <- fs::file_info(fnd)
#>     les_metas$file_size <- f_i$size
#>     les_metas$data_date <- as.character(f_i$modification_time)
#>     if (f_i$size > ctxt$limit_mb * 1024 * 1024) {
#>         fs::file_delete(fnd)
#>         logger::log_warn("cached data not saved because ({scales::label_bytes()(file_size)} is over the {ctxt$limit_md} Mb limit.")
#>     }
#> } else {
#>     fnd <- exists_data_file
#>     les_metas$file_size <- exists_file_size
#>     les_metas$data_date <- exists_data_date
#> }
#> debug: fnd <- fs::path_join(c(ctxt$full_cache_rep, stringr::str_c(ctxt$basename, 
#>     "_", stringr::str_c(data$data_hash, ".qs2"))))
#> debug: qs2::qs_save(data$data, file = fnd, nthreads = getOption("sourcoise.nthreads"))
#> debug: f_i <- fs::file_info(fnd)
#> debug: les_metas$file_size <- f_i$size
#> debug: les_metas$data_date <- as.character(f_i$modification_time)
#> debug: if (f_i$size > ctxt$limit_mb * 1024 * 1024) {
#>     fs::file_delete(fnd)
#>     logger::log_warn("cached data not saved because ({scales::label_bytes()(file_size)} is over the {ctxt$limit_md} Mb limit.")
#> }
#> debug: les_metas$data_file <- data$data_file <- fs::path_file(fnd)
#> debug: if (!is.null(ctxt$log_file)) les_metas$log_file <- fs::path_rel(ctxt$log_file, 
#>     ctxt$root)
#> debug: data$data_date <- les_metas$data_date
#> debug: write_meta(les_metas, ctxt)
#> Error in UseMethod("filter"): no applicable method for 'filter' applied to an object of class "list"
# we then refresh all caches
sourcoise_refresh()
#> ℹ No cache data
#> ℹ No cache data
#> Error in dplyr::filter(what, .data$exists): ℹ In argument: `.data$exists`.
#> Caused by error in `.data$exists`:
#> ! Column `exists` not found in `.data`.
```
