---
title: "sourcoise() : plus rapide, plus sûr"
vignette: >
  %\VignetteIndexEntry{sourcoise}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}

format:
  html:
    code-fold: true
    code-summary: "code"

echo: true
message: false
warning: false
---

## Mettre en cache le résultat des calculs avec `sourcoise()`


## Comment l'utiliser ?

Première chose mettre son code de données dans un script et l'enregistrer là où est le qmd, dans cet exemple `souverains.qmd` et un dossier remplis de csv, scripts R, etc :

```bash         
├── ipch.qmd
└── ipch
    └── ipch_PiM.R
```

Dans `souverains.qmd` on trouve le chunk suivant. `sourcoise()` est capable de retrouver le dossier dans le même dossier que le `qmd` (ce n'est pas automatique, dans un projet commme la prévision, les chemins sont relatifs à la racine du projet, ici le qmd et ses fichiers peuvent être mis n'importe où grâce à cette heuristique). Le source est ensuite exécuté en changeant le dossier de travail à celui qui le contient (dans cet exemple, `souverains`) ce qui permet d'utiliser des chemins relatifs et donc de pouvoir transporter le code n'importe où.

````qmd
```r
library(sourcoise)

ipch <- sourcoise("ipch/ipch.r", lapse = "1 month")

ggplot(icpch$)
```
````

Le script doit se terminer par un `return` qui renvoie les données calculées ou téléchargées. Ce sont ces données qui sont mises en cache.

````         
```r
library(INSEE)
library(tidyverse)
...
télécharge et modifie, calcule, etc
...
return(taux_souverains_historiques)
```
````

`sourcoise()` dispose d'un cache (caché dans un dossier `.data`). Il repère le fichier source et détecte les changements faits au code source et invalide le cache. Si le cache est valide, les données sont renvoyées, sinon, le script est exécuté et les nouvelles données mises en cache.

Il existe d'autres moyens d'invalider le cache : il peut avoir une durée de vie maximale, comme avec l'argument `lapse="day"`. Cette option dit que si le cache est plus vieux que 24h, il est renouvelé par une ré-exécution du script. Ce paramètre peut prendre plusieurs valeurs et des formes comme `2 hours` ou `3 weeks`. D'autres déclencheurs temporels seront ajoutés pour introduire des calendriers (comme 45 jours après la fin du trimestre). Attention, cependant, `source_cache` n'est pas capable d'aller vérifier que les données téléchargées ont un point de plus et donc de ne pas valider le cache si la donnée n'a pas encore été publiée.

Il est aussi possible de déclencher l'invalidation du cache si un fichier a été modifié. Il suffit de fournir une liste de fichiers (dont les chemins sont relatifs au script) qui seront suivis. Ces fichiers peuvent être des `.csv` ou des fichiers `.xlsx` (ou encore tout autre type de fichier) et donc sont utiles pour déclencher l'exécution du script quand on a fait une modification manuelle ou par un autre programme de ces fichiers. On peut en mettre autant qu'on veut.

On peut également forcer le déclenchement du script. Cela se fait par une option `force_exec=TRUE`. Cependant, il vaut mieux ne pas spécifier cette option, il existe d'autres moyens pour opérer un rafraîchissement du cache.

Il est possible de bloquer l'exécution du code par une option (`prevent_exec`) qui peut être définie comme une option globale (par `options(ofce.source_data.prevent_exec=TRUE)`). Dans ce cas, aucun script ne sera exécuté, ce qui peut servir lorsqu'on veut faire un rendu du site sans prendre le risque d'une erreur d'API ou d'un blocage.

## Comment utiliser sourcoise

Le cas d'usage central de `sourcoise()` 

un projet R ou quarto.

des qmd, appelant sourcoise() pour l'acquisition des données et produisant tableaux ou graphiques à partir de ces données.

des scripts R, dans le même dossier ou ailleurs, qui produisent les données à partir de calculs, d'interrogation de bases externes ou d'API. Des objets plus complexes peuvent être renvoyés, comme par exemple des listes d'objets, des graphiques, des tableaux, des fonctions fabriquant des tableaux ou des graphiques, etc...

lorsqu'un cache est disponible et valide (voir plus bas) il est utilisé et la fonction répond très rapidement suivant la taille des données (0.006 secondes pour des données de 2Mb).

tout cela est conçu pour fonctionner avec github et donc partager le cache entre utilisateurs d'un même dépot. On peut donc mettre à jour les données sur une machine et les utiliser sur une autre.

une dernière chose, sourcoise() est doté d'une heuristique maline trouve le fichier source même si il est caché (i.e. que le chemin est approximatif, ce qui déclenche une erreur normalement, mais là ça passe), ce qui augmente la portabilité des fichiers sources et facilite l'orgnisation d'un projet. Bien sûr, en cas d'ambiguité, sourcoise() prévient.

un exemple
Par exemple, si le script R prix_insee.r utilise l'API de l'INSEE pour télécharger l'indice des prix à la consommation, et si il se termine par l'instruction return(ipc), alors sourcoise("prix_insee.r") renvoie toujours les données correspondantes, et si elles sont en cache, le retour est très rapide et ne nécessite pas d'accès à internet.

library(insee)
library(tidyverse)

ipchm <- get_idbank_list("IPCH-2015") |>
     filter(COICOP2016=="00", FREQ=="M", NATURE=="INDICE") |> 
     pull(idbank) |>
     get_insee_idbank() |>
     select(DATE, ipch = OBS_VALUE, IDBANK)

ipch <- ipchm |>
     mutate(DATE = floor_date(DATE, unit="quarter")) |>
     group_by(DATE) |>
     summarise(ipch = mean(ipch))

ipcha <- ipch |> 
     mutate(y = year(DATE)) |> 
     group_by(y) |>
     summarize(ipch = mean(ipch)) |> 
     mutate(ipch = ipch / ipch[y == 2023])

return(list(ipcha = ipcha, ipchm = ipchm, ipch = ipch))
Dans le qmd on a alors un chunk r :

library(sourcoise)
ipc <- sourcoise("prix_insee.r")
ggplot(ipc$ipch) + ...
Le stockage des données a une faible empreinte disque (elles ne servent qu'à construire un graphique, il y a donc une série ou deux, trois dans cet exemple), ce qui ne pose pas de problème pour github. Si l'API de l'INSEE est en panne, alors le cache sera utilisé. On peut réutiliser cette instruction de nombreuses fois, puisqu'elle ne sera exécuté réellement qu'une fois et que les autres fois, c'est le cache qui est utilisé.

sourcoise() exécute le script en local, ce qui limite les effets de bord.



## Usage avancé : passer des paramètres

Il est possible de passer des paramètres avec `sourcoise()`, bien que ce soit plus pratique d'écrire une fonction. Les paramètres sont passés sous forme d'une liste (`list(param1="1")` par exemple) et sont disponibles dans le script (dans la variable `args`, donc pour avoir le paramètre `param1` il faut écrire `args$param1` dans le script. Changer les paramètres invalide le cache.

Notez que le script est toujours exécuté en "local" ce qui veut dire que toute variable créée ou tout package ouvert à l'intérieur du script n'est pas renvoyé (comme dans une fonction, en fait).

## Usage avancé : récupérer les métadonnées

En utlisant l'option `metadata=TRUE` dans `sourcoise()` on peut récupérer des informations sur, par exmple, la date de téléchargement. C'est illustré sur quelques graphiques du cachier de graphique.

En code cela donne le chunk ci dessous. Les données sont accessibles par `$data` et la date de téléchargement par `$date`. Cela permet de construire la note (noter que `glue::glue()` est appliqué aux textes passés à `ofce_caption()`).

```r
transactions <- sourcoise("immo/data_transaction.r", metadata=TRUE)

trsc <- ggplot(transactions$data) + 
  aes(x=date, y=t*1000) +
  geom_line(alpha = 0.5, col = bluish) +
  geom_point_interactive(aes(tooltip = tooltip, data_id = date),
                         shape = 21, size = 1, stroke = 0.2, col = "white", 
                         fill = bluish,
                         hover_nearest = TRUE, show.legend = FALSE)+
  theme_ofce() +
  scale_y_log10(labels = scales::number_format(scale = 1/1000, suffix="k")) +
  scalex +
  ofce_caption(
    source = "IGEDD d'après DGFiP (MEDOC) et bases notariale", 
    dpt = transactions$data$date,
    note = "Transactions cumulées sur 12 mois, dans l'ancien, maisons et appartements, échelle log, données téléchargées le {date_jour(transactions$date)}",
    sub= "Nombre de transactions")

```

## Quelques opérations sur le cache

Le package `{sourcoise}` fournit des outils pour s'occuper des caches. Le premier est `sourcoise_status()`. il scanne le répertoire et fournit la liste de tous les caches enregistrés et suivis. Il indique si les caches sont valides ou non et les principaux paramètres utilisés pour chaque script.

`sourcoise_refresh()` rafraîchit (en le forçant) tous les caches. On peut passer à `sourcoise_refresh()` un `tibble` comme celui renvoyé par `sourcoise_status()` mais filtré pour ne rafraîchir que la liste voulue (attention passer toutes les colonnes sans modification). Cela sert lorsqu'on a un processus plus complexe d'invalidation du cache (en fonction d'un calendrier, en interrogeant une API, etc...) et qu'on déclenche en fonction de cette logique l'exécution des caches.

On peut également à partir de `sourcoise_status()` accéder aux données en cache. Elles sont enregistrées en `.qs2` avec les ackage `{qs2}` et donc se chargent avec un `qs2::qs_read()`.

On peut également nettoyer complètement le cache (ce qui provoquera sa ré exécution) avec `sourcoise_clear()`.
