[{"path":"https://xtimbeau.github.io/sourcoise/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 sourcoise authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"mettre-en-cache-le-résultat-des-calculs-avec-sourcoise","dir":"Articles","previous_headings":"","what":"Mettre en cache le résultat des calculs avec sourcoise()","title":"sourcoise() : plus rapide, plus sûr","text":"sourcoise() est une fonction qui permet de mettre en cache les résultats d’un script r et de ne pas avoir à ré-exécuter le code à chaque fois. Les bénéfices sont nombreux : un gain de temps lorsque l’exécution du code est longue (accès à une API, téléchargement de grosses données, traitements importants). La lecture d’un fichier excel peut aussi être assez longue. Le temps d’accès aux données en cache dépend de leur taille, mais même pour des données volumineuses (et il n’y pas de raisons qu’elles le soient tant que ça), l’ordre de grandeur est de qualques millisecondes, grâce aux optimisations. le cache est transférable par github. Il se trouve dans un dossier (caché), mais enregistré dans le dossier de projet et commité par github. Le cache produit sur un poste est donc accessible par pull sur les autres postes. si le code source déclenche une erreur, peut passer outre : En cas de package non installé, données absentes (par exemple un chemin absolu dans le code), ou une API qui bloque (comme celle de l’OCDE) alors sourcoise() essaye de prendre la dernière exécution résussie. Bien que cela puisse être problématique, c’est-à-dire une erreur non signalée, cela l’énorme avantage de ne pas bloquer le processus et de permettre de traiter l’erreur en parallèle. sourcoise() cherche de façon astucieuse le fichier source dans le projet et exécute le code dans un environnement local, en changeant le répertoire de travail pour être celui où se trouve le code source. Cela permet d’appeler dans le code source (le script r mon_script.r passé en paramètre à sourcoise(\"mon_script.r\"), des scripts r, des fichiers de données .csv ou .xlsx qui sont enregistré dans le même répertoire que le fichier mon_script.r. peut donc réutiliser le code sans se soucier de modifier les chemins qui sont relatifs au dossier où se trouve mon_script.r. cela fournit un embryon de reproductibilité en désignant le script qui fabrique les données.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"comment-lutiliser","dir":"Articles","previous_headings":"","what":"Comment l’utiliser ?","title":"sourcoise() : plus rapide, plus sûr","text":"Première chose mettre son code de données dans un script et l’enregistrer là où est le qmd, dans cet exemple souverains.qmd et un dossier remplis de csv, scripts R, etc : Dans souverains.qmd trouve le chunk suivant. sourcoise() est capable de retrouver le dossier dans le même dossier que le qmd (ce n’est pas automatique, dans un projet commme la prévision, les chemins sont relatifs à la racine du projet, ici le qmd et ses fichiers peuvent être mis n’importe où grâce à cette heuristique). Le source est ensuite exécuté en changeant le dossier de travail à celui qui le contient (dans cet exemple, souverains) ce qui permet d’utiliser des chemins relatifs et donc de pouvoir transporter le code n’importe où. Le script doit se terminer par un return qui renvoie les données calculées ou téléchargées. Ce sont ces données qui sont mises en cache. sourcoise() dispose d’un cache (caché dans un dossier .data). Il repère le fichier source et détecte les changements faits au code source et invalide le cache. Si le cache est valide, les données sont renvoyées, sinon, le script est exécuté et les nouvelles données mises en cache. Il existe d’autres moyens d’invalider le cache : il peut avoir une durée de vie maximale, comme avec l’argument lapse=\"day\". Cette option dit que si le cache est plus vieux que 24h, il est renouvelé par une ré-exécution du script. Ce paramètre peut prendre plusieurs valeurs et des formes comme 2 hours ou 3 weeks. D’autres déclencheurs temporels seront ajoutés pour introduire des calendriers (comme 45 jours après la fin du trimestre). Attention, cependant, source_cache n’est pas capable d’aller vérifier que les données téléchargées ont un point de plus et donc de ne pas valider le cache si la donnée n’pas encore été publiée. Il est aussi possible de déclencher l’invalidation du cache si un fichier été modifié. Il suffit de fournir une liste de fichiers (dont les chemins sont relatifs au script) qui seront suivis. Ces fichiers peuvent être des .csv ou des fichiers .xlsx (ou encore tout autre type de fichier) et donc sont utiles pour déclencher l’exécution du script quand fait une modification manuelle ou par un autre programme de ces fichiers. peut en mettre autant qu’veut. peut également forcer le déclenchement du script. Cela se fait par une option force_exec=TRUE. Cependant, il vaut mieux ne pas spécifier cette option, il existe d’autres moyens pour opérer un rafraîchissement du cache. Il est possible de bloquer l’exécution du code par une option (prevent_exec) qui peut être définie comme une option globale (par options(ofce.source_data.prevent_exec=TRUE)). Dans ce cas, aucun script ne sera exécuté, ce qui peut servir lorsqu’veut faire un rendu du site sans prendre le risque d’une erreur d’API ou d’un blocage.","code":"├── souverains │   ├── ratings.R │   ├── ratings.rds │   ├── ratings_legende.rds │   ├── ratings_taux.rds │   ├── taux_souverains_historiques.R │   └── taux_souverains_historiques.rds └── souverains.qmd library(sourcoise)  taux_souverains_historiques <- sourcoise(\"souverains/taux_souverains_historiques.R\", lapse = \"day\")  ratings_taux <- sourcoise(\"souverains/ratings\", lapse = \"day\") ```r library(INSEE) library(tidyverse) ... télécharge et modifie, calcule, etc ... return(taux_souverains_historiques) ```"},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"usage-avancé-passer-des-paramètres","dir":"Articles","previous_headings":"","what":"Usage avancé : passer des paramètres","title":"sourcoise() : plus rapide, plus sûr","text":"Il est possible de passer des paramètres avec sourcoise(), bien que ce soit plus pratique d’écrire une fonction. Les paramètres sont passés sous forme d’une liste (list(param1=\"1\") par exemple) et sont disponibles dans le script (dans la variable args, donc pour avoir le paramètre param1 il faut écrire args$param1 dans le script. Changer les paramètres invalide le cache. Notez que le script est toujours exécuté en “local” ce qui veut dire que toute variable créée ou tout package ouvert à l’intérieur du script n’est pas renvoyé (comme dans une fonction, en fait).","code":""},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"usage-avancé-récupérer-les-métadonnées","dir":"Articles","previous_headings":"","what":"Usage avancé : récupérer les métadonnées","title":"sourcoise() : plus rapide, plus sûr","text":"En utlisant l’option metadata=TRUE dans sourcoise() peut récupérer des informations sur, par exmple, la date de téléchargement. C’est illustré sur quelques graphiques du cachier de graphique. En code cela donne le chunk ci dessous. Les données sont accessibles par $data et la date de téléchargement par $date. Cela permet de construire la note (noter que glue::glue() est appliqué aux textes passés à ofce_caption()).","code":"transactions <- sourcoise(\"immo/data_transaction.r\", metadata=TRUE)  trsc <- ggplot(transactions$data) +    aes(x=date, y=t*1000) +   geom_line(alpha = 0.5, col = bluish) +   geom_point_interactive(aes(tooltip = tooltip, data_id = date),                          shape = 21, size = 1, stroke = 0.2, col = \"white\",                           fill = bluish,                          hover_nearest = TRUE, show.legend = FALSE)+   theme_ofce() +   scale_y_log10(labels = scales::number_format(scale = 1/1000, suffix=\"k\")) +   scalex +   ofce_caption(     source = \"IGEDD d'après DGFiP (MEDOC) et bases notariale\",      dpt = transactions$data$date,     note = \"Transactions cumulées sur 12 mois, dans l'ancien, maisons et appartements, échelle log, données téléchargées le {date_jour(transactions$date)}\",     sub= \"Nombre de transactions\")"},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"quelques-opérations-sur-le-cache","dir":"Articles","previous_headings":"","what":"Quelques opérations sur le cache","title":"sourcoise() : plus rapide, plus sûr","text":"Le package sourcoise fournit des outils pour s’occuper des caches. Le premier est sourcoise_status(). il scanne le répertoire et fournit la liste de tous les caches enregistrés et suivis. Il indique si les caches sont valides ou non et les principaux paramètres utilisés pour chaque script. sourcoise_refresh() rafraîchit (en le forçant) tous les caches. peut passer à sourcoise_refresh() un tibble comme celui renvoyé par sourcoise_status() mais filtré pour ne rafraîchir que la liste voulue (attention passer toutes les colonnes sans modification). Cela sert lorsqu’un processus plus complexe d’invalidation du cache (en fonction d’un calendrier, en interrogeant une API, etc…) et qu’déclenche en fonction de cette logique l’exécution des caches. peut également à partir de sourcoise_status() accéder aux données en cache. Elles sont enregistrées en .qs2 avec les ackage qs2 et donc se chargent avec un qs2::qs_read(). peut également nettoyer complètement le cache (ce qui provoquera sa ré exécution) avec sourcoise_clear().","code":""},{"path":"https://xtimbeau.github.io/sourcoise/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Xavier Timbeau. Author, maintainer.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Timbeau X (2025). sourcoise: Exec script, like source, cache results disk. R package version 0.3.1, https://xtimbeau.github.io/sourcoise/, https://xtimbeau.github.io/sourcoise.","code":"@Manual{,   title = {sourcoise: Exec a script, like source, and cache results on disk},   author = {Xavier Timbeau},   year = {2025},   note = {R package version 0.3.1, https://xtimbeau.github.io/sourcoise/},   url = {https://xtimbeau.github.io/sourcoise}, }"},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"sourcoise-","dir":"","previous_headings":"","what":"Exec a script, like source, and cache results on disk","title":"Exec a script, like source, and cache results on disk","text":"sourcoise est un package qui fournit des outils pour exécuter un script R et mettre en cache les résultats. Le est de pouvoir exécuter très rapidement un code qui accède à des fichiers ou une API et qui, en l’absence de mises à jour, produit toujours le même résultat. Lorsque l’API est suceptible de bloquer (ou si pas de connection internet), cela évite de bloquer le rendu d’un document ou d’un site quarto. Accessoirement, cela oblige à isoler le code du script qui récupère les données dans un fichier afin d’améliorer la reproductibilité. sourcoise() peut être appelé dans un sourcoise() ce qui permet la modularité. Il fournit des outils pour vérifier le cache et le rafraichir à la demande.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"installation","dir":"","previous_headings":"","what":"installation","title":"Exec a script, like source, and cache results on disk","text":"Pour installer sourcoise il faut le faire depuis github :","code":"devtools::install_gitub(\"xtimbeau/sourcoise\")  # alternativement pak::pak(\"xtimbeau/sourcoise\")"},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"utilisation","dir":"","previous_headings":"","what":"utilisation","title":"Exec a script, like source, and cache results on disk","text":"La structure est donc : un projet R ou quarto. des qmd, appelant sourcoise() pour l’acquisition des données et produisant tableaux ou graphiques à partir de ces données. des scripts R, dans le même dossier ou ailleurs, qui produisent les données à partir de calculs, d’interrogation de bases externes ou d’API. Des objets plus complexes peuvent être renvoyés, comme par exemple des listes d’objets, des graphiques, des tableaux, des fonctions fabriquant des tableaux ou des graphiques, etc… lorsqu’un cache est disponible et valide (voir plus bas) il est utilisé et la fonction répond très rapidement suivant la taille des données (0.006 secondes pour des données de 2Mb). tout cela est conçu pour fonctionner avec github et donc partager le cache entre utilisateurs d’un même dépot. peut donc mettre à jour les données sur une machine et les utiliser sur une autre. une dernière chose, sourcoise() est doté d’une heuristique maline trouve le fichier source même si il est caché (.e. que le chemin est approximatif, ce qui déclenche une erreur normalement, mais là ça passe), ce qui augmente la portabilité des fichiers sources et facilite l’orgnisation d’un projet. Bien sûr, en cas d’ambiguité, sourcoise() prévient.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"un-exemple","dir":"","previous_headings":"","what":"un exemple","title":"Exec a script, like source, and cache results on disk","text":"Par exemple, si le script R prix_insee.r utilise l’API de l’INSEE pour télécharger l’indice des prix à la consommation, et si il se termine par l’instruction return(ipc), alors sourcoise(\"prix_insee.r\") renvoie toujours les données correspondantes, et si elles sont en cache, le retour est très rapide et ne nécessite pas d’accès à internet. Dans le qmd alors un chunk r : Le stockage des données une faible empreinte disque (elles ne servent qu’à construire un graphique, il y donc une série ou deux, trois dans cet exemple), ce qui ne pose pas de problème pour github. Si l’API de l’INSEE est en panne, alors le cache sera utilisé. peut réutiliser cette instruction de nombreuses fois, puisqu’elle ne sera exécuté réellement qu’une fois et que les autres fois, c’est le cache qui est utilisé. sourcoise() exécute le script en local, ce qui limite les effets de bord.","code":"library(insee) library(tidyverse)  ipchm <- get_idbank_list(\"IPCH-2015\") |>      filter(COICOP2016==\"00\", FREQ==\"M\", NATURE==\"INDICE\") |>       pull(idbank) |>      get_insee_idbank() |>      select(DATE, ipch = OBS_VALUE, IDBANK)  ipch <- ipchm |>      mutate(DATE = floor_date(DATE, unit=\"quarter\")) |>      group_by(DATE) |>      summarise(ipch = mean(ipch))  ipcha <- ipch |>       mutate(y = year(DATE)) |>       group_by(y) |>      summarize(ipch = mean(ipch)) |>       mutate(ipch = ipch / ipch[y == 2023])  return(list(ipcha = ipcha, ipchm = ipchm, ipch = ipch)) library(sourcoise) ipc <- sourcoise(\"prix_insee.r\") ggplot(ipc$ipch) + ..."},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"par-rapport-à-memoise","dir":"","previous_headings":"","what":"par rapport à memoise","title":"Exec a script, like source, and cache results on disk","text":"memoise::memoise() propose une solution assez proche, avec la possibilité de rendre le cache persistant entre sessions. Mais memoise() répond au besoin de l’évaluation d’une fonction, qui pour un même jeu de paramètres renvoie toujours la même chose. Ce qui est la définition d’une fonction dans la paradigme fonctionnel sans effet de bord. Le cache permet alors d’échanger espace disque contre performance. sourcoise() part d’une hypothèse différente. Le bout de code appelé ressemble à une fonction mais n’en est pas une : les mêmes arguments peuvent renvoyer une valeur différente. C’est le cas notamment lors de l’accès à une API à des données qui renvoie souvent la même chose, mais périodiquement propose une nouvelle version, avec un effet de bord. Le temps d’accès à l’API eut être long et évebntuellement l’accès hasardeux. les appels à l’API peuvent être dans un workflow typique quarto/R très fréquent (à chaque rendu par exemple), sourcoise() permet donc de mettre en cache et de déclencher une “vraie” exécution périodiquement mais pas tgrop souvent. Si l’appel à l’API est très long, le gain en performance peut être considérable et si l’API bloque parfois, alors sourcoise() permet de continuer le reste du flow sans interruption. L’exécution de l’API peut ainsi être asynchrone, dans un process différent ou sur une machine différente, la synchronisation étant assurée par github ou `pins. Par rapport à memoise::memoise(), sourcoise() utilise systématiquement un cache sur disque, persistant, localisé dans le projet R ou quarto et destiné à être synchronisé par github. Il s’applique à un script et non à une fonction et utilise des règles d’invalidation du cache différentes : le cache est conçu principalement pour être passé entre session. Il est utilisé lors du rendu d’un .qmd et il est transportable avec les fichiers associés. le cache est invalidé si le script est modifié (similaire à l’invalidation par le corps de la fonction dans memoise::memoise()). le cache est invalidé en fonction du delai entre deux exécutions. Il est possible de ré-exécuter le code si il n’pas été exécuté depuis une heure, une journée, une semaine, etc… le cache est invalidé si un ou plusieurs fichiers (définis au préalable) ont été modifiés. Cela sert en particulier à invalider le cache si un fichier de données (.csv ou .xls) été modifié. le cache est invalidé si les arguments passés à sourcoise() pour le script ont été modifiés (comme dans memoise::memoise()). peut également forcer l’invalidation du cache par un paramètre passé à la fonction, éventuellement un paramètre global ou en utilisant la fonction sourcoise_refresh(). Ce dernier point est une différence important par rapport à memoise::memoise() et permet une exécution régulière du rafraichissement du cache. peut logger les accès à sourcoise() ce qui permet de comprendre pourquoi le cache n’est pas invalidé et quels sont fichiers qui ont déclenché sourcoise(). Un dossier .logs est ajouté au dossier du projet. peut limiter la taille du cache, par le paramètre grow_cache qui contraint l’historique du cache et par limit_mb qui empêche de mettre en cache des données au delà d’une taille limite ; par défaut 50mb, pour ne pas fâcher github.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"autres-fonctionalités","dir":"","previous_headings":"","what":"autres fonctionalités","title":"Exec a script, like source, and cache results on disk","text":"sourcoise() peut également invalider les freeze employés par quarto. Les qmd appelant le script sont enregistrés avec le cache et lorsque celui-ci est rafraichit, alors le qmd est unfreezé, ce qui assure que le qmd sera bien re rendu avec les données mises à jour. sourcoise() conserve l’histoirique des données téléchargées et permet donc théoriquement d’y acceder. sourcoise() utilise une heuristique pour trouver la racine du projet, et localiser le script R qui est appelé. cela permet la transportabilité des scripts à l’intérieur d’un projet.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"à-venir","dir":"","previous_headings":"","what":"à venir","title":"Exec a script, like source, and cache results on disk","text":"Seront bientôt implémentés : la possibiité de stocker les données cachées hors de github et d’utiliser pins pour les partager (mais au prix d’un accès plus lent peut être). et éventuellement une interface shiny de mise à jour (gui pour sourcoise_refresh())","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":null,"dir":"Reference","previous_headings":"","what":"sources code and caches results — sourcoise","title":"sources code and caches results — sourcoise","text":"sourcoise() used drop replacement base::source() caches results disk. Cache persistant.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sources code and caches results — sourcoise","text":"","code":"sourcoise(   path,   args = list(),   track = list(),   lapse = getOption(\"sourcoise.lapse\"),   force_exec = getOption(\"sourcoise.force_exec\"),   prevent_exec = getOption(\"sourcoise.prevent_exec\"),   metadata = getOption(\"sourcoise.metadata\"),   wd = getOption(\"sourcoise.wd\"),   src_in = getOption(\"sourcoise.src_in\"),   exec_wd = NULL,   root = NULL,   quiet = FALSE,   nocache = FALSE,   log = getOption(\"sourcoise.log\"),   grow_cache = getOption(\"sourcoise.grow_cache\"),   limit_mb = getOption(\"sourcoise.limit_mb\") )"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"sources code and caches results — sourcoise","text":"path (character) le chemin vers le code à exécuter (sans extension .r ou .R ou avec au choix), ce chemin doit être relatif au projet (voir détails) args (list) une liste d'arguments que l'peut utliser dans source (args$xxx) track (list) une liste de fichiers (suivant la même règle que src pour les trouver) qui déclenchent l'exécution. lapse (character) peut être \"never\" (défaut) \"x hours\", \"x days\", \"x weeks\", \"x months\", \"x quarters\", \"x years\" force_exec (boléen) Si TRUE alors le code est exécuté. prevent_exec (boléen) Si TRUE alors le code n'est pas exécuté, ce flag est prioritaire sur les autres, sauf si il n'y pas de données en cache metadata (boléen) Si TRUE (FALSE par défaut) la fonction retourne une liste avec des métadonnées et le champ data qui contient les données elles même wd (character) si 'project' assure que le wd est le root du project, si 'file' (défaut) c'est le fichier sourcé qui est le wd, si \"qmd\", c'est le qmd qui appelle src_in (character) si \"project\" cherche le source dans le projet puis les sous dossiers, si \"file\" cherche dans le dossier du qmd (ou le wd). Dans ce cas, les données sont stockées dans le dossier en question. exec_wd (character) NULL par défaut sauf usage particulier root (character) force le root (usage non recommandé) quiet (boléen) pas de messages nocache (boléen) n'enregistre pas le cache même si nécessaire log (\"\" par défaut) niveau de cache (voir logger::log_treshold()) grow_cache (5 par défaut) stratégie de cache limit_mb (50 par défaut) limite le fichier de données à x mb (pour github). Si au dessus de la limite, pas de cache.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"sources code and caches results — sourcoise","text":"data (list ou ce que le code retourne)","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"sources code and caches results — sourcoise","text":"However, minor differences. First, script called sourcoise() must end return() object returned. Second, script always executed local environment, working directory changed one script. Third, heuristic applied find script, evnt path given incomplete. closer working directory moment call prefered. Fourth, cas error triggered script, sourcoise() fail return error, except cached data found returned. case, error logged. Cache invalidated : 1 -   cache found 2 -   script modified 3 -   tracked files modified 4 -   last execution occurred certan time ago considered experied 5 -   execution forced Si le paramètre src_in est \"file\", alors le source est cherché à partir du qmd (ou du wd si il n'y pas qmd) et les données sont stockées à ce niveau. Ce cas correspond donc à des dossiers qui ne partagent pas de code (.e. le blog de l'OFCE), alors que l'autre cas correspond à des codes pouvant être partagés (la prévision) Le code est execute (dans un environnement local) et le resultat est mis en cache. Il est important que le code se termine par un return(les_donnees). le code est exécuté avec un contrôle d'erreur, donc si il bloque, \"NULL\" est renvoyé, mais sans erreur ni arrêt. les appels suivants seront plus rapides et sans erreur (sauf si l'erreur n'est pas corrigée). Une modification du code est détectée, invalide le cache et déclenche l'éxécution si sourcoise est exécutée. Suivant le paramètre lapse peut déclencher une exécution périodique. Par exemple, pour ne pas rater une MAJ, peut mettre lapse = \"1 day\" ou \"day\" et une fois par jour le code sera exécuté. Cela permet d'éviter une exécution à chaque rendu, mais permet de vérifier fréquemment la MAJ. peut spécifier l'intervalle en heures (hours), en jours (days), en semaines (weeks), en mois (months) ou en trimestres (quarters). Des métadonnées peuvent être renvoyées (paramètre metadata) avec la date de la dernière exécution ($date), le temps d'exécution ($timing), la taille des données ($size), le chemin de la source ($), le hash du source ($hash_src) et bien sûr les données ($data). Cela peut servir pour renseigner un graphique. Le paramètre wd perment de spécifier le répertoire d'exécution du source. Si il est mis à \"file\", les appels à l'intérieur du code source, comme par exemple un save ou un load seront compris dans le répertoire où se trouve le fichier source. L'intérêt est que le code peut avoir des éléments persistants, locaux L'alternative est d'utiliser wd=\"project\" auquel cas, le répertoire d'exécution sera independant de l'endroit où est appelé le code source. Les éléments persistants peuvent alors être dasn un endroit commun et le code peut appeler des éléments persistants d'autres codes sources. En le mettant à qmdl'exécution part du fichier qmd, ce qui est le comportement standard de quarto. Toute autre valeur pour wd laisse le working directory inchnagé et donc dépendant du contexte d'exécution. Pour ceux qui aiment l'incertitude. En donnant des fichers à suivre par track, peut déclencher l'exécution du source lorsque ces fichiers sont modifiés, c'est utile pour des fichiers sources sous excel (ou csv).","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":null,"dir":"Reference","previous_headings":"","what":"Vide le cache — sourcoise_clear","title":"Vide le cache — sourcoise_clear","text":"Vide le cache","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vide le cache — sourcoise_clear","text":"","code":"sourcoise_clear(   what = sourcoise_status(root = root, prune = FALSE),   root = NULL )"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vide le cache — sourcoise_clear","text":"(–) un tibble issu de source_data, éventuellement filtré root pour forcer le root (non recommandé)","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vide le cache — sourcoise_clear","text":"la liste des fichiers supprimés","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":null,"dir":"Reference","previous_headings":"","what":"Refresh cache by executing sources selected — sourcoise_refresh","title":"Refresh cache by executing sources selected — sourcoise_refresh","text":"Refresh cache executing sources selected","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refresh cache by executing sources selected — sourcoise_refresh","text":"","code":"sourcoise_refresh(   what = NULL,   force_exec = TRUE,   unfreeze = TRUE,   quiet = FALSE,   init_fn = getOption(\"sourcoise.init_fn\"),   root = NULL,   log = \"INFO\",   .progress = TRUE )"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refresh cache by executing sources selected — sourcoise_refresh","text":"(tibble) tibble generated sourcoise_status(), possibly filtered, (defaut source_status() ) force_exec (boolean) TRUE code executed, matter cached unfreeze (boolean) (default TRUE) possible, unfreeze uncache .qmd files quarto project data used .qmd refreshed quiet message TRUE init_fn (function) (default NULL) execute function root (default NULL) force root set, instead letting function finding root, advanced uses log (string) (default \"INFO\") log levels logger::log_threshold() (c(\"\", \"INFO\", ...)), comes performance cost .progress (boolean) (default TRUE) displays progression bar based previous execution timings","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refresh cache by executing sources selected — sourcoise_refresh","text":"list r scripts (characters) executed, timing success","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.html","id":null,"dir":"Reference","previous_headings":"","what":"Efface les .sourcoise — sourcoise_reset","title":"Efface les .sourcoise — sourcoise_reset","text":"Efface les .sourcoise","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efface les .sourcoise — sourcoise_reset","text":"","code":"sourcoise_reset(root = NULL)"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Efface les .sourcoise — sourcoise_reset","text":"root pour forcer le root (non recommandé)","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Etat du cache de sourcoise — sourcoise_status","title":"Etat du cache de sourcoise — sourcoise_status","text":"Donne des informations sur le cache de source_data sous la forme d'un tibble","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Etat du cache de sourcoise — sourcoise_status","text":"","code":"sourcoise_status(   quiet = TRUE,   root = NULL,   src_in = getOption(\"sourcoise.src_in\") %||% \"project\",   prune = TRUE )"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Etat du cache de sourcoise — sourcoise_status","text":"quiet (boléen) TRUE par défaut, ne dit rien root force le root – à ne pas utiliser sauf expert src_in est ce que les données sont avec les qmd ? prune (boléen) limite la liste au dernier cache (TRUE par défaut)","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Etat du cache de sourcoise — sourcoise_status","text":"tibble des fichiers en cache avec les informations des scripts appelants","code":""},{"path":[]},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"correction-de-bugs-0-3-1","dir":"Changelog","previous_headings":"","what":"Correction de bugs","title":"sourcoise 0.3.1","text":"fonctionne correctement avec src_in=\"file\" qui enregistre le cache au niveau du script R sourcé","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"ajouts-0-3-0","dir":"Changelog","previous_headings":"","what":"Ajouts","title":"sourcoise 0.3.0","text":"sourcoise_reset() qui est efface tout (enfin, tout ce que sourcoise fabrique).","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"améliorations-0-3-0","dir":"Changelog","previous_headings":"","what":"Améliorations","title":"sourcoise 0.3.0","text":"sourcoise_clear() est plus prudent et plus efficace. sourcoise_status() est plus robuste et nettoie les data_file orphelins. qs est remplacé par qs2, ce qui corrige le bug de gt (-;) le cache est enregistré dans .sourcoise (ainsi que le log)","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"ajouts-0-2-0","dir":"Changelog","previous_headings":"","what":"Ajouts","title":"sourcoise 0.2.0","text":"sourcoise() son propre package sourcoise, qui est importé dans {ofce}. sourcoise() un système de log (par logger) sourcoise() un système de prune sourcoise() une limite la taille des données sauvegardées","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"correction-de-bugs-0-2-0","dir":"Changelog","previous_headings":"","what":"Correction de bugs","title":"sourcoise 0.2.0","text":"plus quelques bugs réparés.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"sourcoise-010","dir":"Changelog","previous_headings":"","what":"sourcoise 0.1.0","title":"sourcoise 0.1.0","text":"sourcoise() sort du package {ofce} et devient indépendant. Il change de nom (anciennement source_data() qui reste un alias pour la compatibilité descendante)","code":""}]
