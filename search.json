[{"path":"https://xtimbeau.github.io/sourcoise/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 sourcoise authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/articles/compared.html","id":"par-rapport-à-basesource","dir":"Articles","previous_headings":"","what":"par rapport à base::source","title":"Comparé à …","text":"Une alternative à sourcoise() est d’écrire l’enregistrement des données directement dans le script et de charger les données dans le chunk. et dans le chunk r inclure un loadRDS(\"ipch.rds\"). En apparence plus simple cette solution est désastreuse pour le workflow. ne sait pas quel script il faut lancer, quand il été lancé, le chargement du script modifie les variables dans l’environnement, les .rds déclenchent des conflits avec github, bref, que des mauvaises pratiques.","code":"library(insee) library(tidyverse)  ipchm <- get_idbank_list(\"IPCH-2015\") |>      filter(COICOP2016==\"00\", FREQ==\"M\", NATURE==\"INDICE\") |>       pull(idbank) |>      get_insee_idbank() |>      select(DATE, ipch = OBS_VALUE, IDBANK)  ipch <- ipchm |>      mutate(DATE = floor_date(DATE, unit=\"quarter\")) |>      group_by(DATE) |>      summarise(ipch = mean(ipch))  ipcha <- ipch |>       mutate(y = year(DATE)) |>       group_by(y) |>      summarize(ipch = mean(ipch)) |>       mutate(ipch = ipch / ipch[y == 2023])  saveRDS(ipcha , ipchm,  ipch, file = \"ipch.rds\")"},{"path":"https://xtimbeau.github.io/sourcoise/articles/compared.html","id":"par-rapport-à-memoise","dir":"Articles","previous_headings":"","what":"par rapport à memoise","title":"Comparé à …","text":"memoise::memoise() propose une solution proche, avec la possibilité de rendre le cache persistant entre sessions. Mais memoise() répond au besoin de l’évaluation d’une fonction, qui pour un même jeu de paramètres renvoie toujours la même chose. Ce qui est la définition d’une fonction dans la paradigme fonctionnel. Le cache permet alors d’échanger espace disque contre performance. sourcoise() part d’une hypothèse différente, celle d’effets de bord. Le code appelé par le script ressemble à une fonction mais n’en est pas une : les mêmes arguments peuvent renvoyer une valeur différente. C’est le cas notamment lors de l’accès à une API à des données qui renvoie souvent la même chose, mais périodiquement propose une nouvelle version, mise à jour, avec un effet de bord. Le temps d’accès à l’API eut être long et éventuellement l’accès hasardeux (serveur hors ligne, internet coupé). les appels à l’API peuvent être dans un workflow typique quarto/R très fréquent (à chaque rendu par exemple), sourcoise() permet donc de mettre en cache et de ne déclencher une “vraie” exécution que de temps en temps. Si l’appel à l’API est très long, le gain en performance peut être considérable. Si l’API bloque parfois, alors sourcoise() permet de continuer le reste du workflow sans interruption. L’exécution de l’API peut ainsi être asynchrone, dans un process différent ou sur une machine différente, la synchronisation étant assurée par le système de fichier, github ou pins (à venir). Par rapport à memoise::memoise(), sourcoise() utilise systématiquement un cache sur disque, persistant, localisé dans le projet R ou quarto et destiné à être synchronisé par github. Il s’applique à un script et non à une fonction et utilise des règles d’invalidation du cache différentes : le cache est conçu principalement pour être passé entre session. Il est utilisé lors du rendu d’un .qmd et il est transportable avec les fichiers associés. le cache est invalidé si le script est modifié (similaire à l’invalidation par le corps de la fonction dans memoise::memoise()). le cache est invalidé en fonction du delai entre deux exécutions. Il est possible de ré-exécuter le code si il n’pas été exécuté depuis une heure, une journée, une semaine, etc… le cache est invalidé si un ou plusieurs fichiers (définis au préalable) ont été modifiés. Cela sert en particulier à invalider le cache si un fichier de données (.csv ou .xls) été modifié. le cache est invalidé si les arguments passés à sourcoise() pour le script ont été modifiés (comme dans le fonctionnement central de memoise::memoise()). peut également forcer l’invalidation du cache par un paramètre passé à la fonction, éventuellement un paramètre global ou en utilisant la fonction sourcoise_refresh(). Ce dernier point est une différence important par rapport à memoise::memoise() et permet une exécution régulière du rafraichissement du cache indépendamment de l’endroit où est appelé le script. peut logger les accès à sourcoise() ce qui permet de comprendre pourquoi le cache n’est pas invalidé et quels sont fichiers qui ont déclenché sourcoise(). Un dossier logs est ajouté au dossier .sourcoise. peut limiter la taille du cache, par le paramètre grow_cache qui contraint l’historique du cache et par limit_mb qui empêche de mettre en cache des données au delà d’une taille limite ; par défaut 50mb, pour ne pas fâcher github.","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"comment-lutiliser","dir":"Articles","previous_headings":"","what":"Comment l’utiliser ?","title":"sourcoise() : plus rapide, plus sûr","text":"1 - Mettre le code qui fabrique les données dans un script (\"ipch_PiM.r\") et l’enregistrer dans le dossier où est le qmd. Dans cet exemple, le code r télécharge des données (assez volumineuses) sur Eurostat, les transforme et renvoie un tibble prêt pour le graphique. Le script doit se terminer par un return qui renvoie les données calculées ou téléchargées. Ce sont ces données qui sont mises en cache. Le temps d’exécution est de 11s et le script peut bloquer si l’API d’eurostat n’est pas accessible (ou si pas de connection internet). Le script insee.r comporte un return() à la fin : Dans ipch.qmd met le chunk suivant (pas besoin de déclarer les libraries utilisées dans le script) : L’utilisation de sourcoise() se fait comme celle de base::source() à l’assignement prêt. Le résultat est mis en cache et les exécution suivant prennent quelques millisecondes. Ces appels fonctionnent sans téléchargement et donc sasn erreur possible si le serveur d’Eurostat est hors ligne ou que l’plus d’internet. sourcoise() dispose d’un cache (caché dans un dossier .sourcoise). Il repère le fichier source (le script) et détecte les changements, ce qui invalide le cache. Si le cache est valide, les données sont renvoyées, sinon, le script est exécuté et les nouvelles données mises en cache. Il existe d’autres moyens d’invalider le cache : il peut avoir une durée de vie maximale, avec l’argument lapse=\"day\". Cette option dit que si le cache est plus vieux que 24h, il est renouvelé par une ré-exécution du script. Ce paramètre peut prendre plusieurs valeurs et des formes comme 2 hours ou 3 weeks. D’autres déclencheurs temporels seront possiblement ajoutés pour introduire des calendriers (comme 45 jours après la fin du trimestre). Cependant, sourcoise() n’est pas capable d’aller vérifier (de façon générale) que les données téléchargées ont été mise à jour de plus et donc de ne pas invalider le cache sur cette base. Il est aussi possible de déclencher l’invalidation du cache si un autre fichier été modifié. Il suffit de fournir une liste de fichiers (dont les chemins sont relatifs au script) qui seront tracés. Ces fichiers peuvent être des .csv ou des fichiers .xlsx (ou encore tout autre type de fichier) et donc sont utiles pour déclencher l’exécution du script quand fait une modification manuelle ou par un autre programme de ces fichiers. peut en mettre autant qu’veut. peut également forcer le déclenchement du script. Cela se fait par une option force_exec=TRUE. Il existe d’autres moyens pour opérer un rafraîchissement du cache plus généraux. Il est possible de bloquer l’exécution du code par une option (prevent_exec) qui peut être définie comme une option globale (par options(ofce.sourcpose.prevent_exec=TRUE)). Dans ce cas, aucun script ne sera exécuté, ce qui peut servir lorsqu’veut faire un rendu du site sans prendre le risque d’une erreur d’API ou d’un blocage. Il est possible de logger l’exécution de sourcoise() pour vérifier que tout s’est bien passé et de répérer les accès aux données. Une dernière chose, sourcoise() est doté d’une heuristique maline trouve le fichier source même si il est caché (.e. que le chemin est approximatif, ce qui déclenche une erreur normalement, mais là ça passe), ce qui augmente la portabilité des fichiers sources et facilite l’orgnisation d’un projet. Bien sûr, en cas d’ambiguité, sourcoise() prévient.","code":"├── prix.qmd └── ipch     └── prix_insee.R library(insee) library(tidyverse)  ipchm <- get_idbank_list(\"IPCH-2015\") |>      filter(COICOP2016==\"00\", FREQ==\"M\", NATURE==\"INDICE\") |>       pull(idbank) |>      get_insee_idbank() |>      select(DATE, ipch = OBS_VALUE, IDBANK)  ipch <- ipchm |>      mutate(DATE = floor_date(DATE, unit=\"quarter\")) |>      group_by(DATE) |>      summarise(ipch = mean(ipch))  ipcha <- ipch |>       mutate(y = year(DATE)) |>       group_by(y) |>      summarize(ipch = mean(ipch)) |>       mutate(ipch = ipch / ipch[y == 2023])  return(list(ipcha = ipcha, ipchm = ipchm, ipch = ipch)) library(sourcoise) library(tidyverse) ipch_data <- sourcoise(\"ipch/prix_insee.R\")  ggplot(data = ipch_data$ipchm) +    aes(x = DATE, y = ipch ) +   geom_line()"},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"le-workflow-de-sourcoise","dir":"Articles","previous_headings":"","what":"Le workflow de sourcoise","title":"sourcoise() : plus rapide, plus sûr","text":"Le cas central d’utilisation de sourcoise est dans un projet quarto. acuiert des données de diférentes sources, plus ou moins complexes, nécessitant plus ou moins de traitements. Ces donénes peuvent être mises à jour, mais la fréquence de mise à jour est bien plus basse que la fréquence de rendu du projet quarto. Dans les chunks place les mises en forme de graphiques ou de tableaux, afin de pouvoir les corriger et de pouvoir conserver l’adaptation des rendus aux support lors du render du projet quarto. Les données sont fabriquées dans les scripts r, placés là où sont les qmd et appelés périodiquement ou manuellement pour garantir que l’dispose de la version à jour. Ce projet quarto est partagé par github entre plusieurs utilisateurs et les données mises en cache sont commitées (et versionnées) par github. Cela permet de dissocier exécution des scripts (et vérification de leur bonne exécution) du rendu des graphiques ou tableaux faits à partir de ces données. sourcoise_status() permet de faire un inventaire, pour le projet, de toutes les données en cache. Chaque fichier de donnée en cache, c’est-à-dire qui été exéctué pleinement avec succès au moins une fois, est repéré (il existe quelque part dans le projet dans un dossier .sourcoise). Avec ce fichier, quelques informations sont conservés sur l’exécution (date, temps, taille des données) mais aussi sur le contexte d’exécution (script r, qmd appelants). sourcoise_refresh() permet ainsi que rafraicher tout ou partie des données en cache en forçant l’exécution ou en laissant les schémas d’invalidation jouer automatiquement. lorsque les scripts sont exécutés par sourcoise_refresh() le log est activé par défaut. Comme les qmd appelants sont connus, sourcoise_refresh() peut unfreezé ou uncaché les qmdou les chunks des qmd. C’est important dans le workflow, parce que lorsqu’rafraichit les données, veut que les chunks soient réévalués pour que les tableaux ou les graphiques soient refait à partir des nouvelles données. , si utilise freeze quarto n’pas de moyen de savoir que le freeze est périmé. Il est possible de sélectionner les données qui sont rafraichies. sourcoise_refresh() part du résulat de sourcoise_status() par défaut. Il est ainsi possible de faire une sélection des données en cache et de ne passer que celles là à sourcoise_refresh(). Avec un peu de programmation, peut donc mettre en place un schéma qui régulièrement vérifie la validité des données (calendrier, API ou autre) et déclenche séelctivement la mise à jour. sourcoise() peut appeler d’autres sourcoise() mais pour le moment, il n’y aucune prise en compte de cette hiérarchie. un exemple Par exemple, si le script R prix_insee.r utilise l’API de l’INSEE pour télécharger l’indice des prix à la consommation, et si il se termine par l’instruction return(ipc), alors sourcoise(“prix_insee.r”) renvoie toujours les données correspondantes, et si elles sont en cache, le retour est très rapide et ne nécessite pas d’accès à internet. library(insee) library(tidyverse) ipchm <- get_idbank_list(“IPCH-2015”) |> filter(COICOP2016==“00”, FREQ==“M”, NATURE==“INDICE”) |> pull(idbank) |> get_insee_idbank() |> select(DATE, ipch = OBS_VALUE, IDBANK) ipch <- ipchm |> mutate(DATE = floor_date(DATE, unit=“quarter”)) |> group_by(DATE) |> summarise(ipch = mean(ipch)) ipcha <- ipch |> mutate(y = year(DATE)) |> group_by(y) |> summarize(ipch = mean(ipch)) |> mutate(ipch = ipch / ipch[y == 2023]) return(list(ipcha = ipcha, ipchm = ipchm, ipch = ipch)) Dans le qmd alors un chunk r : library(sourcoise) ipc <- sourcoise(“prix_insee.r”) ggplot(ipc$ipch) + … Le stockage des données une faible empreinte disque (elles ne servent qu’à construire un graphique, il y donc une série ou deux, trois dans cet exemple), ce qui ne pose pas de problème pour github. Si l’API de l’INSEE est en panne, alors le cache sera utilisé. peut réutiliser cette instruction de nombreuses fois, puisqu’elle ne sera exécuté réellement qu’une fois et que les autres fois, c’est le cache qui est utilisé. sourcoise() exécute le script en local, ce qui limite les effets de bord.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"usage-avancé-passer-des-paramètres","dir":"Articles","previous_headings":"","what":"Usage avancé : passer des paramètres","title":"sourcoise() : plus rapide, plus sûr","text":"Il est possible de passer des paramètres avec sourcoise(), bien que ce soit plus pratique d’écrire une fonction. Les paramètres sont passés sous forme d’une liste (list(param1=\"1\") par exemple) et sont disponibles dans le script (dans la variable args, donc pour avoir le paramètre param1 il faut écrire args$param1 dans le script. Changer les paramètres invalide le cache. Notez que le script est toujours exécuté en “local” ce qui veut dire que toute variable créée ou tout package ouvert à l’intérieur du script n’est pas renvoyé (comme dans une fonction, en fait).","code":""},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"usage-avancé-récupérer-les-métadonnées","dir":"Articles","previous_headings":"","what":"Usage avancé : récupérer les métadonnées","title":"sourcoise() : plus rapide, plus sûr","text":"En utlisant l’option metadata=TRUE dans sourcoise() peut récupérer des informations sur, par exmple, la date de téléchargement. C’est illustré sur quelques graphiques du cachier de graphique. En code cela donne le chunk ci dessous. Les données sont accessibles par $data et la date de téléchargement par $date. Cela permet de construire la note (noter que glue::glue() est appliqué aux textes passés à ofce_caption()).","code":"transactions <- sourcoise(\"immo/data_transaction.r\", metadata=TRUE)  trsc <- ggplot(transactions$data) +    aes(x=date, y=t*1000) +   geom_line(alpha = 0.5, col = bluish) +   geom_point_interactive(aes(tooltip = tooltip, data_id = date),                          shape = 21, size = 1, stroke = 0.2, col = \"white\",                           fill = bluish,                          hover_nearest = TRUE, show.legend = FALSE)+   theme_ofce() +   scale_y_log10(labels = scales::number_format(scale = 1/1000, suffix=\"k\")) +   scalex +   ofce_caption(     source = \"IGEDD d'après DGFiP (MEDOC) et bases notariale\",      dpt = transactions$data$date,     note = \"Transactions cumulées sur 12 mois, dans l'ancien, maisons et appartements, échelle log, données téléchargées le {date_jour(transactions$date)}\",     sub= \"Nombre de transactions\")"},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"quelques-opérations-sur-le-cache","dir":"Articles","previous_headings":"","what":"Quelques opérations sur le cache","title":"sourcoise() : plus rapide, plus sûr","text":"Le package sourcoise fournit des outils pour s’occuper des caches. Le premier est sourcoise_status(). il scanne le répertoire et fournit la liste de tous les caches enregistrés et suivis. Il indique si les caches sont valides ou non et les principaux paramètres utilisés pour chaque script. sourcoise_refresh() rafraîchit (en le forçant) tous les caches. peut passer à sourcoise_refresh() un tibble comme celui renvoyé par sourcoise_status() mais filtré pour ne rafraîchir que la liste voulue (attention passer toutes les colonnes sans modification). Cela sert lorsqu’un processus plus complexe d’invalidation du cache (en fonction d’un calendrier, en interrogeant une API, etc…) et qu’déclenche en fonction de cette logique l’exécution des caches. peut également à partir de sourcoise_status() accéder aux données en cache. Elles sont enregistrées en .qs2 avec les ackage qs2 et donc se chargent avec un qs2::qs_read(). peut également nettoyer complètement le cache (ce qui provoquera sa ré exécution) avec sourcoise_clear().","code":""},{"path":"https://xtimbeau.github.io/sourcoise/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Xavier Timbeau. Author, maintainer.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Timbeau X (2025). sourcoise: Exec script cache results disk. R package version 0.3.1, https://xtimbeau.github.io/sourcoise/, https://xtimbeau.github.io/sourcoise.","code":"@Manual{,   title = {sourcoise: Exec a script and cache results on disk},   author = {Xavier Timbeau},   year = {2025},   note = {R package version 0.3.1, https://xtimbeau.github.io/sourcoise/},   url = {https://xtimbeau.github.io/sourcoise}, }"},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"sourcoise-","dir":"","previous_headings":"","what":"Exec a script and cache results on disk","title":"Exec a script and cache results on disk","text":"sourcoise est un package qui fournit des outils pour exécuter un script R et mettre en cache les résultats. Le est de pouvoir exécuter très rapidement un code qui accède à des fichiers ou une API et qui, en l’absence de mises à jour, produit toujours le même résultat. Lorsque l’API est suceptible de bloquer (ou si pas de connection internet), cela évite de bloquer le rendu d’un document ou d’un site quarto. Accessoirement, cela oblige à isoler le code du script qui récupère les données dans un fichier afin d’améliorer la reproductibilité. sourcoise() peut être appelé dans un sourcoise() ce qui permet la modularité. Il fournit des outils pour vérifier le cache et le rafraichir à la demande.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"installation","dir":"","previous_headings":"","what":"installation","title":"Exec a script and cache results on disk","text":"Pour installer sourcoise il faut le faire depuis github :","code":"devtools::install_gitub(\"xtimbeau/sourcoise\")  # alternativement pak::pak(\"xtimbeau/sourcoise\")"},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"utilisation","dir":"","previous_headings":"","what":"utilisation","title":"Exec a script and cache results on disk","text":"Pour alimenter un graphique ou un tableau en données, met le code dans un script r (“mon_script.r”) en terminant le script par un return(data_pour_le_graphique). Dans le .qmd ou .rmd (ou aussi un scirpt R) les instructions du graphique : la première exécution le script est exécuté, les appels suivants utiliseront le cache, sauf si le cache est invalidé.","code":"```{r} library(sourcoise) mes_datas <- sourcoise(\"mon_script.r\") ggplot(mes_datas) + instructions du graphique  ```"},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"bénéfices","dir":"","previous_headings":"","what":"bénéfices","title":"Exec a script and cache results on disk","text":"Les bénéfices sont nombreux : un gain de temps lorsque l’exécution du code est longue (accès à une API, téléchargement de grosses données, traitements importants). La lecture d’un fichier excel peut aussi être assez longue. Le temps d’accès aux données en cache dépend de leur taille, mais même pour des données volumineuses (et il n’y pas de raisons qu’elles le soient tant que ça), l’ordre de grandeur est de qualques millisecondes, grâce aux optimisations. le cache est transférable par github. Il se trouve dans un dossier (caché), mais enregistré dans le dossier de projet et commité par github. Le cache produit sur un poste est donc accessible par pull sur les autres postes. si le code source déclenche une erreur, peut passer outre : En cas de package non installé, données absentes (par exemple un chemin absolu dans le code), ou une API qui bloque (comme celle de l’OCDE) alors sourcoise() essaye de prendre la dernière exécution résussie. Bien que cela puisse être problématique, c’est-à-dire une erreur non signalée, cela l’énorme avantage de ne pas bloquer le processus et de permettre de traiter l’erreur en parallèle. sourcoise() cherche de façon astucieuse le fichier source dans le projet et exécute le code dans un environnement local, en changeant le répertoire de travail pour être celui où se trouve le code source. Cela permet d’appeler dans le code source (le script r mon_script.r passé en paramètre à sourcoise(\"mon_script.r\"), des scripts r, des fichiers de données .csv ou .xlsx qui sont enregistré dans le même répertoire que le fichier mon_script.r. peut donc réutiliser le code sans se soucier de modifier les chemins qui sont relatifs au dossier où se trouve mon_script.r. cela fournit un embryon de reproductibilité en désignant le script qui fabrique les données.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"à-venir","dir":"","previous_headings":"","what":"à venir","title":"Exec a script and cache results on disk","text":"Seront bientôt implémentés : la possibilité de stocker les données cachées hors du dossier de projet (et donc horsd de github) et d’utiliser pins pour le stcokage (mais peut être au prix d’un accès plus lent). un schéma pour déclarer les dépendances entre dess appels à sourcoise() et déclencher les exécutions en cascade. et éventuellement une interface shiny de mise à jour (gui pour sourcoise_refresh())","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":null,"dir":"Reference","previous_headings":"","what":"sources R script and caches results on disk — sourcoise","title":"sources R script and caches results on disk — sourcoise","text":"sourcoise() used drop replacement base::source() caches results disk. Cache persistant sessions.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sources R script and caches results on disk — sourcoise","text":"","code":"sourcoise(   path,   args = list(),   track = list(),   lapse = getOption(\"sourcoise.lapse\"),   force_exec = getOption(\"sourcoise.force_exec\"),   prevent_exec = getOption(\"sourcoise.prevent_exec\"),   metadata = getOption(\"sourcoise.metadata\"),   wd = getOption(\"sourcoise.wd\"),   src_in = getOption(\"sourcoise.src_in\"),   exec_wd = NULL,   root = NULL,   quiet = FALSE,   nocache = FALSE,   log = getOption(\"sourcoise.log\"),   grow_cache = getOption(\"sourcoise.grow_cache\"),   limit_mb = getOption(\"sourcoise.limit_mb\") )"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"sources R script and caches results on disk — sourcoise","text":"path (character) path script execute (see details). args (list) list args can used script (form args$xxx). track (list) list files wmodifications trigger cache invalidation script execution . lapse (character) duration cache invalidated. never (default) x hours, x days, x week, x months, x quarters, x years. force_exec (boolean) execute code, disregarding cache valid invalid. prevent_exec (boolean) prenvent execution, cache valid , returned previous cached data, possibly invalid. metadata (boolean) TRUE sourcoise() returns list data $data  various meta data (see details). wd (character) project working directory execution script root project. file dir script (défaut) qmd, working dir dir calling qmd . Current directory restored execution (successful failed). src_in (character) project search source starting root project, si \"file\" cherche dans le dossier du qmd (ou le wd). Dans ce cas, les données sont stockées dans le dossier en question. exec_wd (character) force exec dir (expert use). root (character) force root (expert use). quiet (boolean) silence execution. nocache (boolean) caching. log (\"\" par défaut) log trheshold (see logger::log_treshold()). grow_cache (5 par défaut) cache limit number data file kept. limit_mb (50 par défaut) individual cache data files size disk limit. caching.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"sources R script and caches results on disk — sourcoise","text":"data (list ou ce que le code retourne)","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"sources R script and caches results on disk — sourcoise","text":"sourcoise() looks like base::source(). However, minor differences. First, script called sourcoise() must end return() object returned. Assignment made script kept sourcoise() executed locally. explicitly reruned object returned. soucoise() used assigning result something (aa <- sourcoise(\"mon_script.r) sourcoise() |> ggplot() ...). Unless specified otherwise wd parameter, working directory script execution (temporarly) set dir script. allows simple access companion files permeit move script companion files another dir project. Second, heuristic applied find script, event path given incomplete. Whereas advised comes performance cost, can useful change structure project. heuristic simple, script searched inside porject dir among hits closest caller returned. Third, error triggered script, sourcoise() fail return error NULL return. However, (invalid valid) cache, cached data returned allowing script continue. case error logged. Cache invalidated : 1 -   cache found 2 -   script modified 3 -   tracked files modified 4 -   last execution occurred certan time ago considered experied 5 -   execution forced src_in=\"file\", script path searched .qmd dir. .qmd esxits (caller) current work dir used (usual way base::source works). src_in=\"project\", script path searched root dir project, Rproject quarto project, using package {rprojroot}. garantee find script without using current working directory robust way proceed. Usually fisrt call return cache results. Results can aby R object serialized saved using qs2. Subsequent calls, supposing none cache invalidation true, quick. logging used, data fecteched cache . standard size data, used table graph (< 1Mb roughly), return timing 5ms. lapse parameter used fo rinvalidation trigger 4. lapse = \"1 day\" ou lapse=\"day\" instance trigger day execution. lapse = \"3 days\" every 72h. hours, weeks, months, quarters years understood time units. complex calendar instructions added, sourcoise_refesh() provides solution general easy adapt use case, knowledge, general mechanism warned data updates. track trigger #3. simply list files (following path convention defined scr_in, either script dir project dir reference). files list changed execution triggered. done hash difficult croo plateform hash excel files. Nevertheless, hash done text files results different platforms. metadata=TRUE, list returned, metadatas. Main ones $data, data returned, $date, execution date, $timing execution timing, $size R object memory, $data_file \"data_date documenting data file path last modification date (see ), parameters call ($track, $wd, $src_in, $args ). force_exec prevent_exec parameters force script execution (trigger #5) prevent (cache returned NULL cache). 2 parameters can set one specific execution, intendend global setting option sourcoise.force_exec sourcoise.prevent_exec. returned data execution different previously cached data, caching occurs order limit disk use avoid keeping histoiry data files. implies possibility difference last execution date last data modification date. Working github : sourcoise() designed function github. Cache information specific user (avoiding conflicts) cached data named hash. Conflicts occur rare case script executed different machines script return time different result (random generator).","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":null,"dir":"Reference","previous_headings":"","what":"Vide le cache — sourcoise_clear","title":"Vide le cache — sourcoise_clear","text":"Vide le cache","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vide le cache — sourcoise_clear","text":"","code":"sourcoise_clear(   what = sourcoise_status(root = root, prune = FALSE),   root = NULL )"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vide le cache — sourcoise_clear","text":"(–) un tibble issu de source_data, éventuellement filtré root pour forcer le root (non recommandé)","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vide le cache — sourcoise_clear","text":"la liste des fichiers supprimés","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":null,"dir":"Reference","previous_headings":"","what":"Refresh cache by executing sources selected — sourcoise_refresh","title":"Refresh cache by executing sources selected — sourcoise_refresh","text":"Refresh cache executing sources selected","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refresh cache by executing sources selected — sourcoise_refresh","text":"","code":"sourcoise_refresh(   what = NULL,   force_exec = TRUE,   unfreeze = TRUE,   quiet = FALSE,   init_fn = getOption(\"sourcoise.init_fn\"),   root = NULL,   log = \"INFO\",   .progress = TRUE )"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refresh cache by executing sources selected — sourcoise_refresh","text":"(tibble) tibble generated sourcoise_status(), possibly filtered, (defaut source_status() ) force_exec (boolean) TRUE code executed, matter cached unfreeze (boolean) (default TRUE) possible, unfreeze uncache .qmd files quarto project data used .qmd refreshed quiet message TRUE init_fn (function) (default NULL) execute function root (default NULL) force root set, instead letting function finding root, advanced uses log (string) (default \"INFO\") log levels logger::log_threshold() (c(\"\", \"INFO\", ...)), comes performance cost .progress (boolean) (default TRUE) displays progression bar based previous execution timings","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refresh cache by executing sources selected — sourcoise_refresh","text":"list r scripts (characters) executed, timing success","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.html","id":null,"dir":"Reference","previous_headings":"","what":"Efface les .sourcoise — sourcoise_reset","title":"Efface les .sourcoise — sourcoise_reset","text":"Efface les .sourcoise","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efface les .sourcoise — sourcoise_reset","text":"","code":"sourcoise_reset(root = NULL)"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Efface les .sourcoise — sourcoise_reset","text":"root pour forcer le root (non recommandé)","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Cache status of sourcoise — sourcoise_status","title":"Cache status of sourcoise — sourcoise_status","text":"Given current project, soucoise_status() collects information cache (project level, file level) return tibble data.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cache status of sourcoise — sourcoise_status","text":"","code":"sourcoise_status(quiet = TRUE, root = NULL, prune = TRUE, clean = FALSE)"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cache status of sourcoise — sourcoise_status","text":"quiet (boolean) default TRUE messages execution root (string) (default NULL) force root defined path, advanced recommanded use prune (boolean) (default TRUE) clean status display last relevant caches. clean cache files. clean (boolean) (defaut FALSE) check data files json referring cleans .","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cache status of sourcoise — sourcoise_status","text":"tibble cached files","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cache status of sourcoise — sourcoise_status","text":"Data returned : src: path source file (r script) date: last execution date valid: cache valid ? uid: id user index: index cache timing: last execution timing size: size R object(s) returned lapse: periodic refresh trigger wd: wd setting execution r script args: arguments passed R script json_file: path file keeping cache information qmd_file: list path qmd files calling script (relevant quarto projects) src_in: localisaiton cache option data_file: path data cached data_date: date time last save data log_file: path log file, logging activated root: path project root, used reference paths scr_hash: hash source file track_hash: hash tracked files, track: list files tracked args_hash: hash arguments data_hahs: hahs data cached","code":""},{"path":[]},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"correction-de-bugs-0-3-1","dir":"Changelog","previous_headings":"","what":"Correction de bugs","title":"sourcoise 0.3.1","text":"fonctionne correctement avec src_in=\"file\" qui enregistre le cache au niveau du script R sourcé","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"ajouts-0-3-0","dir":"Changelog","previous_headings":"","what":"Ajouts","title":"sourcoise 0.3.0","text":"sourcoise_reset() qui est efface tout (enfin, tout ce que sourcoise fabrique).","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"améliorations-0-3-0","dir":"Changelog","previous_headings":"","what":"Améliorations","title":"sourcoise 0.3.0","text":"sourcoise_clear() est plus prudent et plus efficace. sourcoise_status() est plus robuste et nettoie les data_file orphelins. qs est remplacé par qs2, ce qui corrige le bug de gt (-;) le cache est enregistré dans .sourcoise (ainsi que le log)","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"ajouts-0-2-0","dir":"Changelog","previous_headings":"","what":"Ajouts","title":"sourcoise 0.2.0","text":"sourcoise() son propre package sourcoise, qui est importé dans {ofce}. sourcoise() un système de log (par logger) sourcoise() un système de prune sourcoise() une limite la taille des données sauvegardées","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"correction-de-bugs-0-2-0","dir":"Changelog","previous_headings":"","what":"Correction de bugs","title":"sourcoise 0.2.0","text":"plus quelques bugs réparés.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"sourcoise-010","dir":"Changelog","previous_headings":"","what":"sourcoise 0.1.0","title":"sourcoise 0.1.0","text":"sourcoise() sort du package {ofce} et devient indépendant. Il change de nom (anciennement source_data() qui reste un alias pour la compatibilité descendante)","code":""}]
