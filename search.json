[{"path":"https://xtimbeau.github.io/sourcoise/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 sourcoise authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/articles/advanced.html","id":"où-sont-les-données-cachées","dir":"Articles","previous_headings":"","what":"Où sont les données cachées ?","title":"Usages avancés","text":"sourcoise() deux modes d’éxécution. Soit au niveau projet et alors les données cachées le sont dans un dossier commun au projet, à la racine du projet. Le dossier dans ce cas s’appelle .sourcoise. La structure du dossier reproduit celle des scripts, avec des dossiers et sous dossiers. Au bout des chemins, il y pour chaque script deux types de fichiers : un json qui contient toutes les métadonnées, est qui est spécifique à chqeu utilisateur. Ce fichier est créé et écrit à chaque fois que le script est exécuté. Il est indéxé par le rang de l’exécution. Le seond type de fichier contient les données et est au format qs2 du package qs2. Ce format peut être directement lu depuis r si le souhaite. Le nom du fichier de données est composé du nom du script et d’un hash sur les données en cache (le hash est calculé sur l’objet r en mémoire et donc ne dépend pas de la plateforme ni du format sur le disque). Le fichier de données n’est écrit que si les données changent. peut donc avoir plusieurs json qui font référence aux mêmes données. Dans le deuxième mode, les données sont stockées au même endroit que le script, toujours dans un dossier caché .sourcoise. y retrouve les json et qs2 suivant les mêmes règles que dans le cas précédent. Si il y plusieurs scripts dans le même dossier, ils partagent le même .sourcoise. Les deux méthodes peuvent cohabiter, ce qui peut conduire à des doublons, qui ne seront pas automatiquement joints. Il est possible d’effacer tous les .sourcoise par la commande sourcoise_reset() et de fixer l’option 1 ou 2 par options(sourcoise.src_in = \"projet\") (option 1.) ou options(sourcoise.src_in = \"file\") (option 2.).","code":""},{"path":"https://xtimbeau.github.io/sourcoise/articles/advanced.html","id":"passer-des-paramètres-au-script","dir":"Articles","previous_headings":"","what":"Passer des paramètres au script","title":"Usages avancés","text":"Il est possible de passer des paramètres avec sourcoise(), bien que ce soit plus pratique d’écrire une fonction. Les paramètres sont passés sous forme d’une liste (list(param1=\"1\") par exemple) et sont disponibles dans le script (dans la variable args, donc pour avoir le paramètre param1 il faut écrire args$param1 dans le script. Changer les paramètres invalide le cache. Notez que le script est toujours exécuté en “local” ce qui veut dire que toute variable créée ou tout package ouvert à l’intérieur du script n’est pas renvoyé (comme dans une fonction, en fait).","code":""},{"path":"https://xtimbeau.github.io/sourcoise/articles/advanced.html","id":"récupérer-les-métadonnées","dir":"Articles","previous_headings":"","what":"Récupérer les métadonnées","title":"Usages avancés","text":"En utlisant l’option metadata=TRUE dans sourcoise() peut récupérer des informations sur, par exmple, la date de téléchargement. C’est illustré sur quelques graphiques du cachier de graphique. En code cela donne le chunk ci dessous. Les données sont accessibles par $data et la date de téléchargement par $date. Cela permet de construire la note (noter que glue::glue() est appliqué aux textes passés à ofce_caption()).","code":"transactions <- sourcoise(\"immo/data_transaction.r\", metadata=TRUE)  trsc <- ggplot(transactions$data) +    aes(x=date, y=t*1000) +   geom_line(alpha = 0.5, col = bluish) +   geom_point_interactive(aes(tooltip = tooltip, data_id = date),                          shape = 21, size = 1, stroke = 0.2, col = \"white\",                           fill = bluish,                          hover_nearest = TRUE, show.legend = FALSE)+   theme_ofce() +   scale_y_log10(labels = scales::number_format(scale = 1/1000, suffix=\"k\")) +   scalex +   ofce_caption(     source = \"IGEDD d'après DGFiP (MEDOC) et bases notariale\",      dpt = transactions$data$date,     note = \"Transactions cumulées sur 12 mois, dans l'ancien, maisons et appartements, échelle log, données téléchargées le {date_jour(transactions$date)}\",     sub= \"Nombre de transactions\")"},{"path":"https://xtimbeau.github.io/sourcoise/articles/advanced.html","id":"quelques-opérations-sur-le-cache","dir":"Articles","previous_headings":"","what":"Quelques opérations sur le cache","title":"Usages avancés","text":"Le package sourcoise fournit des outils pour s’occuper des caches. Le premier est sourcoise_status(). il scanne le répertoire et fournit la liste de tous les caches enregistrés et suivis. Il indique si les caches sont valides ou non et les principaux paramètres utilisés pour chaque script. sourcoise_refresh() rafraîchit (en le forçant) tous les caches. peut passer à sourcoise_refresh() un tibble comme celui renvoyé par sourcoise_status() mais filtré pour ne rafraîchir que la liste voulue (attention passer toutes les colonnes sans modification). Cela sert lorsqu’un processus plus complexe d’invalidation du cache (en fonction d’un calendrier, en interrogeant une API, etc…) et qu’déclenche en fonction de cette logique l’exécution des caches. peut également à partir de sourcoise_status() accéder aux données en cache. Elles sont enregistrées en .qs2 avec les ackage qs2 et donc se chargent avec un qs2::qs_read(). peut également nettoyer complètement le cache (ce qui provoquera sa ré exécution) avec sourcoise_clear().","code":""},{"path":"https://xtimbeau.github.io/sourcoise/articles/compared.html","id":"par-rapport-à-basesource","dir":"Articles","previous_headings":"","what":"par rapport à base::source","title":"Comparé à …","text":"Une alternative à sourcoise() est d’écrire l’enregistrement des données directement dans le script et de charger les données dans le chunk. et dans le chunk r inclure un loadRDS(\"ipch.rds\"). En apparence plus simple cette solution est désastreuse pour le workflow. ne sait pas quel script il faut lancer, quand il été lancé, le chargement du script modifie les variables dans l’environnement, les .rds déclenchent des conflits avec github, bref, que des mauvaises pratiques.","code":"library(insee) library(tidyverse)  ipchm <- get_idbank_list(\"IPCH-2015\") |>      filter(COICOP2016==\"00\", FREQ==\"M\", NATURE==\"INDICE\") |>       pull(idbank) |>      get_insee_idbank() |>      select(DATE, ipch = OBS_VALUE, IDBANK)  ipch <- ipchm |>      mutate(DATE = floor_date(DATE, unit=\"quarter\")) |>      group_by(DATE) |>      summarise(ipch = mean(ipch))  ipcha <- ipch |>       mutate(y = year(DATE)) |>       group_by(y) |>      summarize(ipch = mean(ipch)) |>       mutate(ipch = ipch / ipch[y == 2023])  saveRDS(ipcha , ipchm,  ipch, file = \"ipch.rds\")"},{"path":"https://xtimbeau.github.io/sourcoise/articles/compared.html","id":"par-rapport-à-memoise","dir":"Articles","previous_headings":"","what":"par rapport à memoise","title":"Comparé à …","text":"memoise::memoise() propose une solution proche, avec la possibilité de rendre le cache persistant entre sessions. Mais memoise() répond au besoin de l’évaluation d’une fonction, qui pour un même jeu de paramètres renvoie toujours la même chose. Ce qui est la définition d’une fonction dans la paradigme fonctionnel. Le cache permet alors d’échanger espace disque contre performance. sourcoise() part d’une hypothèse différente, celle d’effets de bord. Le code appelé par le script ressemble à une fonction mais n’en est pas une : les mêmes arguments peuvent renvoyer une valeur différente. C’est le cas notamment lors de l’accès à une API à des données qui renvoie souvent la même chose, mais périodiquement propose une nouvelle version, mise à jour, avec un effet de bord. Le temps d’accès à l’API eut être long et éventuellement l’accès hasardeux (serveur hors ligne, internet coupé). les appels à l’API peuvent être dans un workflow typique quarto/R très fréquent (à chaque rendu par exemple), sourcoise() permet donc de mettre en cache et de ne déclencher une “vraie” exécution que de temps en temps. Si l’appel à l’API est très long, le gain en performance peut être considérable. Si l’API bloque parfois, alors sourcoise() permet de continuer le reste du workflow sans interruption. L’exécution de l’API peut ainsi être asynchrone, dans un process différent ou sur une machine différente, la synchronisation étant assurée par le système de fichier, github ou pins (à venir). Par rapport à memoise::memoise(), sourcoise() utilise systématiquement un cache sur disque, persistant, localisé dans le projet R ou quarto et destiné à être synchronisé par github. Il s’applique à un script et non à une fonction et utilise des règles d’invalidation du cache différentes : le cache est conçu principalement pour être passé entre session. Il est utilisé lors du rendu d’un .qmd et il est transportable avec les fichiers associés. le cache est invalidé si le script est modifié (similaire à l’invalidation par le corps de la fonction dans memoise::memoise()). le cache est invalidé en fonction du delai entre deux exécutions. Il est possible de ré-exécuter le code si il n’pas été exécuté depuis une heure, une journée, une semaine, etc… le cache est invalidé si un ou plusieurs fichiers (définis au préalable) ont été modifiés. Cela sert en particulier à invalider le cache si un fichier de données (.csv ou .xls) été modifié. le cache est invalidé si les arguments passés à sourcoise() pour le script ont été modifiés (comme dans le fonctionnement central de memoise::memoise()). peut également forcer l’invalidation du cache par un paramètre passé à la fonction, éventuellement un paramètre global ou en utilisant la fonction sourcoise_refresh(). Ce dernier point est une différence important par rapport à memoise::memoise() et permet une exécution régulière du rafraichissement du cache indépendamment de l’endroit où est appelé le script. peut logger les accès à sourcoise() ce qui permet de comprendre pourquoi le cache n’est pas invalidé et quels sont fichiers qui ont déclenché sourcoise(). Un dossier logs est ajouté au dossier .sourcoise. peut limiter la taille du cache, par le paramètre grow_cache qui contraint l’historique du cache et par limit_mb qui empêche de mettre en cache des données au delà d’une taille limite ; par défaut 50mb, pour ne pas fâcher github. sourcoise() utilise en fait memoise pour ne pas charger 2 fois les données à partir du disque. Le gain est marginal pour de petites données mais peut jouer lorsque les données sont volumineuses (divise par 100 l’accès pour des données de 50Mb, par 10 pour des données de 5Mb, par 2 pour 500kb).","code":""},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"comment-lutiliser","dir":"Articles","previous_headings":"","what":"Comment l’utiliser ?","title":"sourcoise : sourcer et mettre en cache","text":"Mettre le code qui fabrique les données dans un script (\"prix_insee.r\") et l’enregistrer dans le dossier où est le qmd. Dans cet exemple, le code r télécharge des données (assez volumineuses) sur Eurostat, les transforme et renvoie un tibble prêt pour le graphique. Le script doit se terminer par un return qui renvoie les données calculées ou téléchargées. Ce sont ces données qui sont mises en cache. Le temps d’exécution est de 11s et le script peut bloquer si l’API d’eurostat n’est pas accessible (ou si pas de connection internet). Le script prix_insee.r comporte un return() à la fin : Dans ipch.qmd met le chunk suivant (pas besoin de déclarer les librairies utilisées dans le script) : L’utilisation de sourcoise() se fait comme celle de base::source() à l’assignement prêt. Le résultat est mis en cache et les exécution suivant prennent quelques millisecondes. Ces appels fonctionnent sans téléchargement et donc sasn erreur possible si le serveur d’Eurostat est hors ligne ou que l’plus d’internet. sourcoise() dispose d’un cache (caché dans un dossier .sourcoise). Il repère le fichier source (le script) et détecte les changements, ce qui invalide le cache. Si le cache est valide, les données sont renvoyées, sinon, le script est exécuté et les nouvelles données mises en cache. Il existe d’autres moyens d’invalider le cache : il peut avoir une durée de vie maximale, avec l’argument lapse=\"day\". Cette option dit que si le cache est plus vieux que 24h, il est renouvelé par une ré-exécution du script. Ce paramètre peut prendre plusieurs valeurs et des formes comme 2 hours ou 3 weeks. D’autres déclencheurs temporels seront possiblement ajoutés pour introduire des calendriers (comme 45 jours après la fin du trimestre). Cependant, sourcoise() n’est pas capable d’aller vérifier (de façon générale) que les données téléchargées ont été mise à jour de plus et donc de ne pas invalider le cache sur cette base. Il est aussi possible de déclencher l’invalidation du cache si un autre fichier été modifié. Il suffit de fournir une liste de fichiers (dont les chemins sont relatifs au script) qui seront tracés. Ces fichiers peuvent être des .csv ou des fichiers .xlsx (ou encore tout autre type de fichier) et donc sont utiles pour déclencher l’exécution du script quand fait une modification manuelle ou par un autre programme de ces fichiers. peut en mettre autant qu’veut. peut également forcer le déclenchement du script. Cela se fait par une option force_exec=TRUE. Il existe d’autres moyens pour opérer un rafraîchissement du cache plus généraux. Il est possible de bloquer l’exécution du code par une option (prevent_exec) qui peut être définie comme une option globale (par options(ofce.sourcpose.prevent_exec=TRUE)). Dans ce cas, aucun script ne sera exécuté, ce qui peut servir lorsqu’veut faire un rendu du site sans prendre le risque d’une erreur d’API ou d’un blocage. L’exécution du code s’effectue en local (donc pas d’effet de bord das l’environnement qui appelle le script) et modifie le working directory pour qu’il soit celui du script appelé. Cela permet alors d’utiliser des chemins relatifs à ce dossier. il est possible de modifier ce comportement par une option. Il est possible de logger l’exécution de sourcoise() pour vérifier que tout s’est bien passé et de répérer les accès aux données. Une dernière chose : sourcoise() est doté d’une heuristique maline trouve le fichier source même si il est caché (.e. que le chemin est approximatif, ce qui déclenche une erreur normalement, mais là ça passe), ce qui augmente la portabilité des fichiers sources et facilite l’orgnisation d’un projet. Bien sûr, en cas d’ambiguité, sourcoise() prévient.","code":"├── prix.qmd └── prix_insee.R library(insee) library(tidyverse)  ipchm <- get_idbank_list(\"IPCH-2015\") |>      filter(COICOP2016==\"00\", FREQ==\"M\", NATURE==\"INDICE\") |>       pull(idbank) |>      get_insee_idbank() |>      select(DATE, ipch = OBS_VALUE, IDBANK)  ipch <- ipchm |>      mutate(DATE = floor_date(DATE, unit=\"quarter\")) |>      group_by(DATE) |>      summarise(ipch = mean(ipch))  ipcha <- ipch |>       mutate(y = year(DATE)) |>       group_by(y) |>      summarize(ipch = mean(ipch)) |>       mutate(ipch = ipch / ipch[y == 2023])  # le return final return(list(ipcha = ipcha, ipchm = ipchm, ipch = ipch)) library(sourcoise) library(tidyverse) ipch_data <- sourcoise(\"prix_insee.R\")  ggplot(data = ipch_data$ipchm) +    aes(x = DATE, y = ipch ) +   geom_line()"},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"sourcoise : sourcer et mettre en cache","text":"L’exécution “vraie” du scirpt r (sur un Macbook Air M2) prend 34ms et alloue 200kb. Lorsque les données sont en cache, l’exécution est effectuée en moins de 5ms et l’allocation de mémoire est celle des données finales. Le temps d’exécution des données cachées ne dépend que de leur taille alors que le temsp d’exécution “vraie” dépend de la complexité des calculs et des volumes téléchargés par le script. L’acces direct est bien sûr (infiniment) plus rapide, mais sans invalidation de cache ! Created 2025-03-10 reprex v2.1.1","code":"library(bench) library(fs) library(sourcoise) file_copy(     path_package(\"sourcoise\", \"ipch\", \"prix_insee.r\"),     \"/tmp/prix_insee.r\",     overwrite = TRUE) data <- sourcoise(\"prix_insee.r\", root=\"/tmp\") mark(cache = sourcoise(\"prix_insee.r\", root=\"/tmp\"),             no_cache = sourcoise(\"prix_insee.r\", root  = \"/tmp\", force_exec = TRUE),             direct = data) #>   |                                                                              |                                                                      |   0%  |                                                                              |======================================================================| 100% #> # A tibble: 3 × 6 #>   expression      min   median    `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>        <dbl> <bch:byt>    <dbl> #> 1 cache        5.61ms   5.75ms        171.    171.5KB     9.92 #> 2 no_cache    31.62ms  35.45ms         28.0    25.6MB    11.2  #> 3 direct            0      1ns 1370228815.         0B     0"},{"path":"https://xtimbeau.github.io/sourcoise/articles/sourcoise.html","id":"le-workflow-avec-sourcoise","dir":"Articles","previous_headings":"","what":"Le workflow avec sourcoise","title":"sourcoise : sourcer et mettre en cache","text":"Le cas central d’utilisation de sourcoise est dans un projet quarto. acuiert des données de diférentes sources, plus ou moins complexes, nécessitant plus ou moins de traitements. Ces donénes peuvent être mises à jour, mais la fréquence de mise à jour est bien plus basse que la fréquence de rendu du projet quarto. Dans les chunks place les mises en forme de graphiques ou de tableaux, afin de pouvoir les corriger et de pouvoir conserver l’adaptation des rendus aux support lors du render du projet quarto. Les données sont fabriquées dans les scripts r, placés là où sont les qmd et appelés périodiquement ou manuellement pour garantir que l’dispose de la version à jour. Ce projet quarto est partagé par github entre plusieurs utilisateurs et les données mises en cache sont commitées (et versionnées) par github. Cela permet de dissocier exécution des scripts (et vérification de leur bonne exécution) du rendu des graphiques ou tableaux faits à partir de ces données. sourcoise_status() permet de faire un inventaire, pour le projet, de toutes les données en cache. Chaque fichier de donnée en cache, c’est-à-dire qui été exéctué pleinement avec succès au moins une fois, est repéré (il existe quelque part dans le projet dans un dossier .sourcoise). Avec ce fichier, quelques informations sont conservés sur l’exécution (date, temps, taille des données) mais aussi sur le contexte d’exécution (script r, qmd appelants). sourcoise_refresh() permet ainsi que rafraicher tout ou partie des données en cache en forçant l’exécution ou en laissant les schémas d’invalidation jouer automatiquement. lorsque les scripts sont exécutés par sourcoise_refresh() le log est activé par défaut. Comme les qmd appelants sont connus, sourcoise_refresh() peut unfreezé ou uncaché les qmdou les chunks des qmd. C’est important dans le workflow, parce que lorsqu’rafraichit les données, veut que les chunks soient réévalués pour que les tableaux ou les graphiques soient refait à partir des nouvelles données. , si utilise freeze quarto n’pas de moyen de savoir que le freeze est périmé. Il est possible de sélectionner les données qui sont rafraichies. sourcoise_refresh() part du résulat de sourcoise_status() par défaut. Il est ainsi possible de faire une sélection des données en cache et de ne passer que celles là à sourcoise_refresh(). Avec un peu de programmation, peut donc mettre en place un schéma qui régulièrement vérifie la validité des données (calendrier, API ou autre) et déclenche séelctivement la mise à jour. sourcoise() peut appeler d’autres sourcoise() mais pour le moment, il n’y aucune prise en compte de cette hiérarchie.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Xavier Timbeau. Author, maintainer, copyright holder.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Timbeau X (2025). sourcoise: Source Script Cache. R package version 0.5.0.9000, https://github.com/xtimbeau/sourcoise, https://xtimbeau.github.io/sourcoise/.","code":"@Manual{,   title = {sourcoise: Source a Script and Cache},   author = {Xavier Timbeau},   year = {2025},   note = {R package version 0.5.0.9000, https://github.com/xtimbeau/sourcoise},   url = {https://xtimbeau.github.io/sourcoise/}, }"},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"sourcoise--source-and-cache","dir":"","previous_headings":"","what":"Source a Script and Cache","title":"Source a Script and Cache","text":"sourcoise package provides tools running R script caching results. aim able quickly execute code accesses files API , absence updates, always produces result. API likely block (don’t internet connection), avoids blocking rendering document quarto site. also means script code retrieves data file isolated improve reproducibility. sourcoise() can called sourcoise() allows modularity. provides tools, checking cache, sourcoise_status(), refreshing , sourcoise_refresh(), demand.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Source a Script and Cache","text":"sourcoise can installed CRAN: development version can installed github:","code":"install.packages(\"sourcoise\") devtools::install_gitub(\"xtimbeau/sourcoise\")  # or (if pak is installed) pak::pak(\"xtimbeau/sourcoise\")"},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"use","dir":"","previous_headings":"","what":"Use","title":"Source a Script and Cache","text":"populate graph table data, put code script r (\"mon_script.r\"), ending script return(data_pour_le_graphique). .qmd .rmd (also R script) instructions graph r code chunk: first time script run, subsequent calls use cache, unless cache invalidated. check status cache, just call sourcoise_status(). scan project collect info cached data. refresh everything, call sourcoise_refresh(), execute scripts refresh data cache. Options available filter really need refreshed.","code":"```r library(tidyverse) library(sourcoise)  mes_datas <- sourcoise(\"mon_script.r\") ggplot(mes_datas) + <<graph code>>  ```"},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"benefits","dir":"","previous_headings":"","what":"Benefits","title":"Source a Script and Cache","text":"many benefits: time savings code execution takes long time (accessing API, downloading large amounts data, major processing). Reading excel file can also take long time. time taken access cached data depends size, even large data (’s reason large), order magnitude milliseconds, thanks optimization. cache transferable via github. ’s (hidden) folder, saved project folder committed github. cache produced workstation can therefore accessed via pull workstations, without need reexecute code. source code triggers error, can override : case package installed, missing data (example, absolute path code), API blocks (OECD), sourcoise() tries take result last successful execution (cached). Although can problematic, .e. unreported error, enormous advantage blocking process allowing error handled parallel. sourcoise() cleverly searches source file project executes code local environment, changing working directory one source code located. makes possible call source code (script r mon_script.r passed parameter sourcoise(\"mon_script.r\") scripts r data files .csv .xlsx saved directory mon_script.r. can therefore reuse code without worry modifying paths, relative folder mon_script.r . provides embryo reproducibility designating script produces data thus allowing complement code chunk reference reproduce .","code":""},{"path":"https://xtimbeau.github.io/sourcoise/index.html","id":"coming-soon","dir":"","previous_headings":"","what":"Coming soon","title":"Source a Script and Cache","text":"ability store hidden data outside project folder (therefore outside github) use pins stcokage (perhaps cost slower access). schema declaring dependencies calls sourcoise() calls trigger cascade executions. possibly shiny update interface (gui sourcoise_refresh())","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":null,"dir":"Reference","previous_headings":"","what":"sources R script and caches results on disk — sourcoise","title":"sources R script and caches results on disk — sourcoise","text":"sourcoise() used drop replacement base::source() caches results disk. Cache persistant sessions.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sources R script and caches results on disk — sourcoise","text":"","code":"sourcoise(   path,   args = list(),   track = list(),   lapse = getOption(\"sourcoise.lapse\"),   force_exec = getOption(\"sourcoise.force_exec\"),   prevent_exec = getOption(\"sourcoise.prevent_exec\"),   metadata = getOption(\"sourcoise.metadata\"),   wd = getOption(\"sourcoise.wd\"),   src_in = getOption(\"sourcoise.src_in\"),   exec_wd = NULL,   root = NULL,   quiet = TRUE,   nocache = FALSE,   inform = FALSE,   log = getOption(\"sourcoise.log\"),   grow_cache = getOption(\"sourcoise.grow_cache\"),   limit_mb = getOption(\"sourcoise.limit_mb\") )"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"sources R script and caches results on disk — sourcoise","text":"path (character) path script execute (see details). args (list) list args can used script (form args$xxx). track (list) list files modification triggers cache invalidation script execution . lapse (character) duration cache invalidated. never (default) x hours, x days, x week, x months, x quarters, x years. force_exec (boolean) execute code, disregarding cache valid invalid. prevent_exec (boolean) prevent execution, cache valid , returned previous cached data, possibly invalid. metadata (boolean) TRUE sourcoise() returns list data $data  various meta data (see details). wd (character) project working directory execution script root project. file dir script (défaut) qmd, working dir dir calling qmd . Current directory restored execution (successful failed). src_in (character) project searches source starting root project, \"file\" searches qmd dir. \"wd\", working directory. Cache folder (.sourcoise) stored . exec_wd (character) force exec dir (expert use). root (character) force root (expert use). quiet (boolean) mute messages warnings script execution. nocache (boolean) caching. inform (boolean) Display logs console, even logging disabled threshold level \"INFO\". log (\"\" par défaut) log threshold (see logger::log_treshold()). grow_cache (5 par défaut) cache limit number data file kept. limit_mb (50 par défaut) individual cache data files size disk limit. caching.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"sources R script and caches results on disk — sourcoise","text":"data (list ou ce que le code retourne)","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"sources R script and caches results on disk — sourcoise","text":"sourcoise() looks like base::source(). However, minor differences. First, script called sourcoise() must end return() object returned. Assignment made script kept sourcoise() executed locally. explicitly reruned object returned. soucoise() used assigning result something (aa <- sourcoise(\"mon_script.r) sourcoise() |> ggplot() ...). Unless specified otherwise wd parameter, working directory script execution (temporarly) set dir script. allows simple access companion files permit move script companion files another dir project. Second, heuristic applied find script, event path given incomplete. Whereas advised comes performance cost, can useful change structure project. heuristic simple, script searched inside porject dir among hits closest caller returned. Third, error triggered script, sourcoise() fail return error NULL return. However, (invalid valid) cache, cached data returned allowing script continue. case error logged. Cache invalidated : 1 -   cache found 2 -   script modified 3 -   tracked files modified 4 -   last execution occurred certain time ago considered expired 5 -   execution forced src_in=\"file\", script path searched .qmd dir. .qmd esxits (caller) current work dir used (usual way base::source works). src_in=\"project\", script path searched root dir project, Rproject quarto project, using package {rprojroot}. guarantees find script without using current working directory robust way proceed. Usually fisrt call return cache results. Results can aby R object serialized saved using qs2. Subsequent calls, supposing none cache invalidation true, quick. logging used, data fecteched cache . standard size data, used table graph (< 1Mb roughly), return timing 5ms. lapse parameter used invalidation trigger 4. lapse = \"1 day\" ou lapse=\"day\" instance trigger day execution. lapse = \"3 days\" every 72h. hours, weeks, months, quarters years understood time units. complex calendar instructions added, sourcoise_refesh() provides solution general easy adapt use case, knowledge, general mechanism warned data updates. track trigger #3. simply list files (following path convention defined scr_in, either script dir project dir reference). files list changed execution triggered. done hash difficult croo plateform hash excel files. Nevertheless, hash done text files results different platforms. metadata=TRUE, list returned, metadatas. Main ones $data, data returned, $date, execution date, $timing execution timing, $size R object memory, $data_file, $data_date  $file_size documenting data file path, date size disk last modification date, parameters call ($track, $wd, $src_in, $args ). force_exec prevent_exec parameters force script execution (trigger #5) prevent (cache returned NULL cache). 2 parameters can set one specific execution, intendend global setting option sourcoise.force_exec sourcoise.prevent_exec. returned data execution different previously cached data, caching occurs order limit disk use avoid keeping history data files. implies possibility difference last execution date last data modification date. insterested moment data changed, $data_date preferred. Working github : sourcoise() designed function github. Cache information specific user (avoiding conflicts) cached data named hash. Conflicts occur rare case script executed different machines script return time different result (random generator).","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"sources R script and caches results on disk — sourcoise","text":"","code":"dir <- tempdir() fs::file_copy(    fs::path_package(\"sourcoise\", \"ipch\", \"prix_insee.R\"),   dir,   overwrite = TRUE) # Force execution (root is set explicitly here, it is normally deduced from project) data <- sourcoise(\"prix_insee.R\", root = dir, force_exec = TRUE) # The second time cache is used data <- sourcoise(\"prix_insee.R\", root = dir) # Performance and mem test dir <- tempdir() fs::file_copy(    fs::path_package(\"sourcoise\", \"ipch\", \"prix_insee.R\"),    dir,    overwrite = TRUE) bench::mark(  forced = data <- sourcoise(\"prix_insee.r\", root = dir, force_exec = TRUE),  cached = data <- sourcoise(\"prix_insee.r\", root = dir),  max_iterations = 5) #> # A tibble: 2 × 13 #>   expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time #>   <bch:expr> <bch:tm> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> #> 1 forced      83.58ms   86ms      10.2    1.91MB        0     5     0      489ms #> 2 cached       9.38ms  9.5ms     105.   258.07KB        0     5     0     47.8ms #> # ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":null,"dir":"Reference","previous_headings":"","what":"Cleans sourcoise cache — sourcoise_clear","title":"Cleans sourcoise cache — sourcoise_clear","text":"removes every json qs2 files found sourcoise_status() unless specific tibble (filtered sourcoise_status()) passed argument.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cleans sourcoise cache — sourcoise_clear","text":"","code":"sourcoise_clear(   what = sourcoise_status(root = root, prune = FALSE),   root = NULL )"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cleans sourcoise cache — sourcoise_clear","text":"(–) tibble one obtained sourcoise_status(), possibly filtered root force root, recommended (expert use)","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cleans sourcoise cache — sourcoise_clear","text":"list cleared files, plus side-effect specified cache files deleted (undo possible)","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_clear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cleans sourcoise cache — sourcoise_clear","text":"","code":"dir <- tempdir() fs::file_copy(     fs::path_package(\"sourcoise\", \"ipch\", \"prix_insee.R\"),     dir,     overwrite = TRUE) # Force execution (root is set explicitly here, it is normally deduced from project) data <- sourcoise(\"prix_insee.R\", root = dir, force_exec = TRUE) # we then clear all caches sourcoise_clear(root = dir) #> [1] \"prix_insee.r\" sourcoise_status(root = dir) #> # A tibble: 0 × 0"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":null,"dir":"Reference","previous_headings":"","what":"Refresh sourcoise cache by executing sources selected — sourcoise_refresh","title":"Refresh sourcoise cache by executing sources selected — sourcoise_refresh","text":"scripts (passed sourcoise_refresh()) executed logging enabled.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refresh sourcoise cache by executing sources selected — sourcoise_refresh","text":"","code":"sourcoise_refresh(   what = NULL,   force_exec = TRUE,   unfreeze = TRUE,   quiet = FALSE,   init_fn = getOption(\"sourcoise.init_fn\"),   root = NULL,   log = \"INFO\",   .progress = TRUE )"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refresh sourcoise cache by executing sources selected — sourcoise_refresh","text":"(tibble) tibble generated sourcoise_status(), possibly filtered, (defaut source_status() ) force_exec (boolean) (default FALSE) TRUE code executed, matter cached unfreeze (boolean) (default TRUE) possible, unfreeze uncache .qmd files quarto project data used .qmd refreshed quiet (boolean) (default FALSE) message TRUE init_fn (function) (default NULL) execute function sourcing allow initialization root (default NULL) force root set, instead letting function finding root, advanced uses log (character) (default \"INFO\") log levels logger::log_threshold() (c(\"\", \"INFO\", ...)), comes small performance cost .progress (boolean) (default TRUE) displays progression bar based previous execution timings","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refresh sourcoise cache by executing sources selected — sourcoise_refresh","text":"list r scripts (characters) executed, timing success side effect caches","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refresh sourcoise cache by executing sources selected — sourcoise_refresh","text":"function returns list script executed main effect side-effect scripts executed caches updates accordingly. Note also log files reflect execution track possible errors. logging execution comes loss performance, issue scripts long execute. possible execute sourcoise_refresh() without execution forcing (force_exec=FALSE) . Forced execution means script executed even cache valid. case non forced execution, execution triggered cache invalidation tests (change source file, lapse tacked files). scripts linked qmds (.e. run quarto project), possible unfreeeze uncache qmds option unfreeze=TRUE. allows refresh cahe render qmds using new data. possible pass refresh function executed every script. allows load packages declare global variables can used script. packages loaded inside script, needed. Parameters registered ins sourcoise_status() wd args used execute script.","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_refresh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refresh sourcoise cache by executing sources selected — sourcoise_refresh","text":"","code":"dir <- tempdir() fs::file_copy(    fs::path_package(\"sourcoise\", \"ipch\", \"prix_insee.R\"),    dir,    overwrite = TRUE) # Force execution (root is set explicitly here, it is normally deduced from project) data <- sourcoise(\"prix_insee.R\", root = dir, force_exec = TRUE) # we then refresh all caches sourcoise_refresh(root = dir) #> ✔ prix_insee.r exectued in 0 s. for 14 kB of data #> ℹ Total refresh in 0 seconds for 14 kB of data"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.html","id":null,"dir":"Reference","previous_headings":"","what":"Resets sourcoise — sourcoise_reset","title":"Resets sourcoise — sourcoise_reset","text":"Removes .sourcoise folders found project root.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resets sourcoise — sourcoise_reset","text":"","code":"sourcoise_reset(root = NULL)"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resets sourcoise — sourcoise_reset","text":"root force root (expert use)","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resets sourcoise — sourcoise_reset","text":"return, effect removal .sourcoise folders (side effect, undo possible)","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_reset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Resets sourcoise — sourcoise_reset","text":"","code":"dir <- tempdir() fs::file_copy(    fs::path_package(\"sourcoise\", \"ipch\", \"prix_insee.R\"),    dir,    overwrite = TRUE) data <- sourcoise(\"prix_insee.R\", root = dir, force_exec = TRUE) sourcoise_reset(root = dir)"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Cache status of sourcoise — sourcoise_status","title":"Cache status of sourcoise — sourcoise_status","text":"Given current project, soucoise_status() collects information cache (project level, file level) return tibble data.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cache status of sourcoise — sourcoise_status","text":"","code":"sourcoise_status(quiet = TRUE, root = NULL, prune = TRUE, clean = FALSE)"},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cache status of sourcoise — sourcoise_status","text":"quiet (boolean) (default TRUE) messages execution root (string) (default NULL) force root defined path, advanced recommanded use prune (boolean) (default TRUE) clean status display relevant cache. However, clean cache files. clean (boolean) (default FALSE) check data files json referring cleans .","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cache status of sourcoise — sourcoise_status","text":"tibble cached files (see details structure)","code":""},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cache status of sourcoise — sourcoise_status","text":"sourcoise_status() reflects disk (results indeed scan cached files metadatas). modifying result sourcoise_status() can produce complex bugs passed sourcoise_refresh() sourcoise_clean(). Data returned : src: path source file (r script) date: last execution date valid: cache valid ? uid: id user index: index cache timing: last execution timing size: size R object(s) returned lapse: periodic refresh trigger wd: wd setting execution r script args: arguments passed R script json_file: path file keeping cache information qmd_file: list path qmd files calling script (relevant quarto projects) src_in: localisaiton cache option data_file: path data cached data_date: date time last save data log_file: path log file, logging activated root: path project root, used reference paths scr_hash: hash source file track_hash: hash tracked files, track: list files tracked args_hash: hash arguments data_hash: hash data cached","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/reference/sourcoise_status.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cache status of sourcoise — sourcoise_status","text":"","code":"dir <- tempdir() fs::file_copy(     fs::path_package(\"sourcoise\", \"ipch\", \"prix_insee.R\"),     dir,     overwrite = TRUE) # Force execution (root is set explicitly here, it is normally deduced from project) data <- sourcoise(\"prix_insee.R\", root = dir, force_exec = TRUE) # status returns the cache status sourcoise_status(root = dir) #> # A tibble: 1 × 22 #>   src      date                valid uid   index timing size  lapse wd    args   #>   <chr>    <dttm>              <lgl> <chr> <dbl>  <dbl> <chr> <chr> <chr> <list> #> 1 prix_in… 2025-03-15 20:06:45 TRUE  77f2…     1 0.0502 14 kB never file  <NULL> #> # ℹ 12 more variables: json_file <fs::path>, qmd_file <list>, src_in <chr>, #> #   data_file <chr>, data_date <chr>, file_size <chr>, log_file <chr>, #> #   root <chr>, src_hash <chr>, track_hash <list>, track <list>, #> #   data_hash <chr>"},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"correction-de-bugs-development-version","dir":"Changelog","previous_headings":"","what":"Correction de bugs","title":"sourcoise (development version)","text":"enregistre correctement le champ date (quand cache est retourné) ignore.case dans les recherches de fichiers enregistre correctement le chemin du log si le cache est invalide les arguments sont employés (par un hash) pour différencier les caches, ce qui permet de les utiliser sans problème.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"sourcoise-050","dir":"Changelog","previous_headings":"","what":"sourcoise 0.5.0","title":"sourcoise 0.5.0","text":"CRAN release: 2025-03-15 CRAN version","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"sourcoise-040","dir":"Changelog","previous_headings":"","what":"sourcoise 0.4.0","title":"sourcoise 0.4.0","text":"CRAN version","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"correction-de-bugs-0-3-3","dir":"Changelog","previous_headings":"","what":"Correction de bugs","title":"sourcoise 0.3.3","text":"traite correctement les sources multiples et trouve le plus proche mieux","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"ajouts-0-3-3","dir":"Changelog","previous_headings":"Correction de bugs","what":"Ajouts","title":"sourcoise 0.3.3","text":"utilise memoise pour cacher en mémoire les données sur disque","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"correction-de-bugs-0-3-2","dir":"Changelog","previous_headings":"","what":"Correction de bugs","title":"sourcoise 0.3.2","text":"retourne un cache invalide si l’éxécution échouée. n’exécute plus deux fois le source lorsque l’éxécution échoue. meilleurs messages d’erreur ou de succès","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"correction-de-bugs-0-3-1","dir":"Changelog","previous_headings":"","what":"Correction de bugs","title":"sourcoise 0.3.1","text":"fonctionne correctement avec src_in=\"file\" qui enregistre le cache au niveau du script R sourcé","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"ajouts-0-3-0","dir":"Changelog","previous_headings":"","what":"Ajouts","title":"sourcoise 0.3.0","text":"sourcoise_reset() qui est efface tout (enfin, tout ce que sourcoise fabrique).","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"améliorations-0-3-0","dir":"Changelog","previous_headings":"","what":"Améliorations","title":"sourcoise 0.3.0","text":"sourcoise_clear() est plus prudent et plus efficace. sourcoise_status() est plus robuste et nettoie les data_file orphelins. qs est remplacé par qs2, ce qui corrige le bug de gt (-;) le cache est enregistré dans .sourcoise (ainsi que le log)","code":""},{"path":[]},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"ajouts-0-2-0","dir":"Changelog","previous_headings":"","what":"Ajouts","title":"sourcoise 0.2.0","text":"sourcoise() son propre package sourcoise, qui est importé dans {ofce}. sourcoise() un système de log (par logger) sourcoise() un système de prune sourcoise() une limite la taille des données sauvegardées","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"correction-de-bugs-0-2-0","dir":"Changelog","previous_headings":"","what":"Correction de bugs","title":"sourcoise 0.2.0","text":"plus quelques bugs réparés.","code":""},{"path":"https://xtimbeau.github.io/sourcoise/news/index.html","id":"sourcoise-010","dir":"Changelog","previous_headings":"","what":"sourcoise 0.1.0","title":"sourcoise 0.1.0","text":"sourcoise() sort du package {ofce} et devient indépendant. Il change de nom (anciennement source_data() qui reste un alias pour la compatibilité descendante)","code":""}]
